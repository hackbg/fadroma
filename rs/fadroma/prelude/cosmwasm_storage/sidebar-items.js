initSidebarItems({"fn":[["bucket",""],["bucket_read",""],["currval","currval returns the last value returned by nextval. If the sequence has never been used, then it will return 0."],["nextval","nextval increments the counter by 1 and returns the new value. On the first time it is called (no sequence info in db) it will return 1."],["prefixed",""],["prefixed_read",""],["sequence","Sequence creates a custom Singleton to hold an empty sequence"],["singleton",""],["singleton_read",""],["to_length_prefixed","Calculates the raw key prefix for a given namespace as documented in https://github.com/webmaster128/key-namespacing#length-prefixed-keys"],["to_length_prefixed_nested","Calculates the raw key prefix for a given nested namespace as documented in https://github.com/webmaster128/key-namespacing#nesting"],["transactional",""],["typed",""],["typed_read",""]],"struct":[["Bucket",""],["PrefixedStorage",""],["ReadonlyBucket",""],["ReadonlyPrefixedStorage",""],["ReadonlySingleton","ReadonlySingleton only requires a ReadonlyStorage and exposes only the methods of Singleton that donâ€™t modify state."],["ReadonlyTypedStorage",""],["RepLog",""],["Singleton","Singleton effectively combines PrefixedStorage with TypedStorage to work on a single storage key. It performs the to_length_prefixed transformation on the given name to ensure no collisions, and then provides the standard TypedStorage accessors, without requiring a key (which is defined in the constructor)"],["StorageTransaction",""],["TypedStorage",""]]});