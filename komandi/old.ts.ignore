
export async function runCommand (
  context:      any,
  commands:     any,
  commandToRun: string,
  ...args:      Array<any>
) {
  if (commandToRun) {

    let notFound = true

    for (const [nameOrNames, info, fn, subcommands] of commands.filter(Boolean)) {

      const singleMatch = (typeof nameOrNames === 'string' && nameOrNames === commandToRun)

      const multiMatch  = (nameOrNames instanceof Array && nameOrNames.indexOf(commandToRun) > -1)

      if (singleMatch || multiMatch) {

        notFound = false
        let notImplemented = true

        if (fn) {
          // allow subcommands to add to the context by returning an updated value
          // but preserve it if they return nothing (they can still mutate it)
          context = await Promise.resolve(fn(context, ...args)) || context
          notImplemented = false
        }

        let arg

        while (arg = args.shift()) {
          if (arg.includes('=')) {
            const [key, val] = arg.split('=')
            context.options = Object.assign(context.options || {}, { [key]: val })
          } else {
            args.unshift(arg)
            break
          }
        }

        if (subcommands && subcommands.length > 0) {
          context.command.push(args[0])
          runCommand(context, subcommands, args[0], ...args.slice(1))
          notImplemented = false
        }

        if (notImplemented) {
          console.warn(`${commandToRun}: not implemented`)
        }
      }
    }
    if (notFound) {
      console.warn(`${commandToRun}: no such command`)
    }
  } else {
    printUsage(context, commands)
  }
}


export function printUsage (context: any, commands: any) {
  const prefix = context.command.length > 0 ? ((context.command||[]).join(' ')) : ''
  console.log(`\nsienna ${prefix}[COMMAND...]\n`)
  const tableData = collectUsage(context, commands)
  process.stdout.write(table(tableData, noBorders)) }

function collectUsage (
  context = {}, commands: any, tableData = [], visited = new Set(), depth = 0
) {
  const maxDepth = -1 // increment to display command tree in depth
  const indent = Array(depth+1).join('  ')
  for (const commandSpec of commands) {
    if (!commandSpec) {
      tableData.push(['','',''])
      continue }
    let [command, docstring, _, subcommands] = commandSpec
    if (visited.has(commandSpec)) {
      tableData.push([`  ${indent}${bold(command)}`, '(see above)', '']) }
    else {
      visited.add(commandSpec)
      if (command instanceof Array) command = command.join(', ')
      if (depth > maxDepth && subcommands && subcommands.length > 0) {
        tableData.push([
          `  ${indent}${bold(command)}`,
          docstring, bold(`${subcommands.length} subcommand${subcommands.length>1?'s':''}...`)]) }
      else {
        tableData.push([
          `  ${indent}${bold(command)}`,
          docstring, ''])
        if (subcommands) {
          collectUsage(context, subcommands, tableData, visited, depth+1) } } } }
  tableData.push(['','',''])
  return tableData }
