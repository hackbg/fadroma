import type {
  Address, Message, ICoin, IFee, CodeHash,
  Class, Name, Many, CodeId,
  Into, TxHash, Label,
  UploadStore
} from './agent'
import {
  CompiledCode,
  ContractUpload,
  ContractInstance,
  ContractClient,
  ContractClientClass
} from './agent-contract'
import {
  Error, Console, bold, into, mapAsync, hideProperties, randomBytes
} from './agent-base'

/** A chain can be in one of the following modes: */
export enum ChainMode {
  Mainnet = 'Mainnet',
  Testnet = 'Testnet',
  Devnet  = 'Devnet',
  Mocknet = 'Mocknet'
}

/** The unique ID of a chain. */
export type ChainId = string

/** A collection of functions that return Chain instances. */
export type ChainRegistry = Record<string, (config: any)=>Chain>

/** Interface for Devnet (implementation is in @hackbg/fadroma). */
export interface DevnetHandle {
  accounts:     string[]
  chainId:      string
  platform:     string
  running:      boolean
  stateDir:     string
  url:          URL

  containerId?: string
  imageTag?:    string
  port?:        string|number

  start (): Promise<this>
  getAccount (name: string): Promise<Partial<Chain>>
  assertPresence (): Promise<void>
}

/** Represents a particular chain, identified by chain ID and connected by URL.
  * The chain can be in one of several modes (mainnet or other), can optionally
  * hold a reference to the managed devnet container, can query state, and can
  * construct authorized agents. */
export abstract class Chain {
  /** The ChainMode enum. */
  static Mode = ChainMode
  /** Create a mainnet instance of this chain. */
  static mainnet (options: Partial<Chain> = {}): Chain & { mode: ChainMode.Mainnet } {
    return new (this as any)({ ...options, mode: Chain.Mode.Mainnet })
  }
  /** Create a testnet instance of this chain. */
  static testnet (options: Partial<Chain> = {}): Chain & { mode: ChainMode.Testnet } {
    return new (this as any)({ ...options, mode: Chain.Mode.Testnet })
  }
  /** Create a devnet instance of this chain. */
  static devnet (options: Partial<Chain> = {}): Chain & { mode: ChainMode.Devnet } {
    return new (this as any)({ ...options, mode: Chain.Mode.Devnet })
  }
  /** Create a mocknet instance of this chain. */
  static mocknet (options?: Partial<Chain>): Chain & { mode: ChainMode.Mocknet } {
    throw new Error('Mocknet is not enabled for this chain.')
  }
  /** Logger. */
  log:      Console = new Console(this.constructor.name)
  /** The API URL to use. */
  url:      string = ''
  /** Instance of the underlying platform API (secretjs, cosmjs, etc.). */
  api?:     unknown
  /** If this is a devnet, this contains an interface to the devnet container. */
  devnet?:  DevnetHandle
  /** Whether this chain is stopped. */
  stopped:  boolean = false
  /** The friendly name of the agent. */
  name?:    string
  /** The address from which transactions are signed and sent. */
  address?: Address
  /** Default fee maximums for send, upload, init, and execute. */
  fees?:    { send?: IFee, upload?: IFee, init?: IFee, exec?: IFee }

  constructor ({ id, url, mode, devnet }: Partial<Chain> = {}) {

    this.name = options.name ?? this.name
    this.fees = options.fees ?? this.fees
    this.address = options.address ?? this.address
    hideProperties(this, 'chain', 'address', 'log', 'Batch')

    if (devnet) {
      Object.defineProperties(this, {
        id: {
          enumerable: true,
          configurable: true,
          get: () => devnet.chainId,
          set: () => { throw new Error("can't override chain id of devnet") }
        },
        url: {
          enumerable: true,
          configurable: true,
          get: () => devnet.url.toString(),
          set: () => { throw new Error("can't override url of devnet") }
        },
        'mode': {
          enumerable: true,
          configurable: true,
          get: () => Chain.Mode.Devnet,
          set: () => { throw new Error("chain.mode: can't override") }
        },
        'devnet': {
          enumerable: true,
          configurable: true,
          get: () => devnet,
          set: () => { throw new Error("chain.devnet: can't override") }
        },
        'stopped': {
          enumerable: true,
          configurable: true,
          get: () => !this.devnet!.running,
          set: () => { throw new Error("chain.stopped: can't override") }
        }
      })
      if (id && id !== devnet.chainId) {
        this.log.warn('chain.id: ignoring override (devnet)')
      }
      if (url && url.toString() !== devnet.url.toString()) {
        this.log.warn('chain.url: ignoring override (devnet)')
      }
      if (mode && mode !== Chain.Mode.Devnet) {
        this.log.warn('chain.mode: ignoring override (devnet)')
      }
    } else {
      if (id) {
        Object.defineProperty(this, 'id', {
          enumerable: true,
          writable:   false,
          value:      id
        })
      }
      if (mode) {
        Object.defineProperty(this, 'mode', {
          enumerable: true,
          writable:   false,
          value:      mode
        })
      }
      this.url = url ?? this.url
    }

    Object.defineProperty(this, 'log', {
      enumerable: false,
      writable: true,
    })

    Object.defineProperty(this, 'Chain', {
      enumerable: false,
      writable: true
    })

  }

  /** Compact string tag for console representation. */
  get [Symbol.toStringTag]() {
    return this.address
      ? `${this.id}: ${this.address}`
      : `${this.id} (unauthenticated)`
  }

  /** The unique chain id. */
  get id (): ChainId {
    throw new Error("chain id not set")
  }
  set id (id: string) {
    throw new Error("can't override chain id")
  }
  /** Whether this is mainnet, public testnet, local devnet, or mocknet. */
  get mode (): ChainMode {
    throw new Error('chain mode not set')
  }
  set mode (id: string) {
    throw new Error("can't override chain mode")
  }
  /** Whether this is a mainnet. */
  get isMainnet () {
    return this.mode === ChainMode.Mainnet
  }
  /** Whether this is a testnet. */
  get isTestnet () {
    return this.mode === ChainMode.Testnet 
  }
  /** Whether this is a devnet. */
  get isDevnet () {
    return this.mode === ChainMode.Devnet
  }
  /** Whether this is a mocknet. */
  get isMocknet () {
    return this.mode === ChainMode.Mocknet
  }
  /** Whether this is a devnet or mocknet. */
  get devMode () {
    return this.isDevnet || this.isMocknet
  }

  abstract getApi ():
    unknown

  get ready () {
    if (this.isDevnet && !this.devnet) {
      throw new Error("the chain is marked as a devnet but is missing the devnet handle")
    }
    type This = this
    type ThisWithApi = This & { api: NonNullable<This["api"]> }
    const init = new Promise<ThisWithApi>(async (resolve, reject)=>{
      if (this.devnet) {
        await this.devnet.start()
      }
      if (!this.api) {
        if (!this.url) {
          throw new Error("the chain's url property is not set")
        }
        this.api = await Promise.resolve(this.getApi())
        //if (!this.mnemonic && this.name && this.devnet) {
          //Object.assign(this, await this.devnet.getAccount(this.name))
        //}
      }
      return resolve(this as ThisWithApi)
    })
    Object.defineProperty(this, 'ready', { get () { return init } })
    return init
  }

  /** Get info about a block. */
  abstract getBlockInfo (block?: number):
    Promise<unknown>

  /** Get the current block height. */
  abstract get height ():
    Promise<number>

  /** Wait for the block height to increment. */
  get nextBlock (): Promise<number> {
    return this.height.then(async startingHeight=>{
      startingHeight = Number(startingHeight)
      if (isNaN(startingHeight)) {
        this.log.warn('current block height undetermined. not waiting for next block')
        return Promise.resolve(NaN)
      }
      this.log.waitingForBlock(startingHeight)
      const t = + new Date()
      return new Promise(async (resolve, reject)=>{
        try {
          while (true && !this.stopped) {
            await new Promise(ok=>setTimeout(ok, 250))
            this.log.waitingForBlock(startingHeight, + new Date() - t)
            const height = await this.height
            if (height > startingHeight) {
              this.log.info(`block height incremented to ${height}, continuing`)
              return resolve(height)
            }
          }
        } catch (e) {
          reject(e)
        }
      })
    })
  }

  /** The default denomination of the chain's native token. */
  abstract defaultDenom:
    string

  /** Get info about a specific account (such as balance). */
  abstract getAccountInfo (address?: Address|{ address?: Address }):
    Promise<unknown>

  /** Send native tokens to 1 recipient. */
  abstract send (to: Address, amounts: ICoin[], options?: unknown):
    Promise<void|unknown>

  /** Send native tokens to multiple recipients. */
  abstract sendMany (outputs: [Address, ICoin[]][], options?: unknown):
    Promise<void|unknown>

  /** Get info about a specific code. */
  abstract getCodeInfo (id: CodeId|{ codeId?: CodeId }):
    Promise<ContractUpload>

  /** Upload a contract's code, generating a new code id/hash pair. */
  async upload (
    code: string|URL|Uint8Array|Partial<CompiledCode>,
    options: {
      reupload?:    boolean,
      uploadStore?: UploadStore,
      uploadFee?:   ICoin[]|'auto',
      uploadMemo?:  string
    } = {},
  ): Promise<ContractUpload & {
    chainId: ChainId,
    codeId:  CodeId,
  }> {
    let template: Uint8Array
    if (code instanceof Uint8Array) {
      template = code
    } else {
      if (typeof code === 'string' || code instanceof URL) {
        code = new CompiledCode({ codePath: code })
      } else {
        code = new CompiledCode(code)
      }
      const t0 = performance.now()
      template = await (code as CompiledCode).fetch()
      const t1 = performance.now() - t0
      this.log.log(
        `Fetched in`,
        bold(t1.toFixed(3)),
        `msec:`,
        bold(String(code.codeData?.length)),
        `bytes`
      )
    }
    const t0 = performance.now()
    const result = await this.doUpload(template, options)
    const t1 = performance.now() - t0
    this.log.log(
      `Uploaded in`,
      bold(t1.toFixed(3)),
      `msec: code id`,
      bold(String(result.codeId)),
      `on chain`,
      bold(result.chainId)
    )
    return new ContractUpload({ ...template, ...result }) as ContractUpload & {
      chainId: ChainId,
      codeId:  CodeId,
    }
  }

  /** Chain-specific upload logic. */
  protected abstract doUpload (
    data: Uint8Array,
    options: Parameters<typeof this["upload"]>[1]
  ): Promise<Partial<ContractUpload>>

  abstract getContractInfo (address: Address|{ address?: Address }):
    Promise<ContractInstance>

  /** Create a new smart contract from a code id, label and init message.
    * @example
    *   await agent.instantiate(template.define({ label, initMsg })
    * @returns
    *   ContractInstance with no `address` populated yet.
    *   This will be populated after executing the batch. */
  async instantiate (
    contract: CodeId|Partial<ContractUpload>,
    options:  Partial<ContractInstance>
  ): Promise<ContractInstance & { address: Address, }> {
    if (typeof contract === 'string') {
      contract = new ContractUpload({ codeId: contract })
    }
    if (isNaN(Number(contract.codeId))) {
      throw new Error.Invalid('code id')
    }
    if (!contract.codeId) {
      throw new Error.Missing.CodeId()
    }
    if (!options.label) {
      throw new Error.Missing.Label()
    }
    if (!options.initMsg) {
      throw new Error.Missing.InitMsg()
    }
    const t0 = performance.now()
    const result = await this.doInstantiate(contract.codeId, {
      ...options,
      initMsg: await into(options.initMsg)
    })
    const t1 = performance.now() - t0
    this.log.debug(
      `Instantiated in`,
      bold(t1.toFixed(3)),
      `msec: code id`,
      bold(String(contract.codeId)),
      `address`,
      bold(result.address)
    )
    return new ContractInstance({
      ...options,
      ...result
    }) as ContractInstance & {
      address: Address
    }
  }

  /** Chain-specific instantiate logic. */
  protected abstract doInstantiate (
    contract: CodeId,
    options:  Partial<ContractInstance>
  ): Promise<Partial<ContractInstance>>

  /** Call a transaction method on a smart contract. */
  async execute (
    contract: Address|Partial<ContractInstance>,
    message:  Message,
    options?: { execFee?: IFee, execSend?: ICoin[], execMemo?: string }
  ): Promise<unknown> {
    if (typeof contract === 'string') contract = new ContractInstance({ address: contract })
    if (!contract.address) throw new Error("agent.execute: no contract address")
    const t0 = performance.now()
    const result = await this.doExecute(contract as { address: Address }, message, options)
    const t1 = performance.now() - t0
    return result
  }

  /** Chain-specific execute logic. */
  protected abstract doExecute (
    contract: Partial<ContractInstance>, message: Message, options?: Parameters<this["execute"]>[2]
  ): Promise<unknown>

  /** Query a contract on the chain. */
  query <Q> (
    contract: Address|Partial<ContractInstance>, message: Message
  ): Promise<Q> {
    if (typeof contract === 'string') contract = { address: contract }
    return this.doQuery(contract, message)
  }

  /** Chain-specific query logic. */
  protected abstract doQuery <Q> (
    contract: Partial<ContractInstance>, message: Message
  ): Promise<Q>

  batch (callback?: (batch: Batch)=>unknown): Batch {
    return new Batch(this, callback)
  }

  /** Get a client instance for talking to a specific smart contract as this executor. */
  getClient <C extends ContractClient> (
    contract: Partial<ContractInstance> = {},
    $C: ContractClientClass<C> = ContractClient as unknown as ContractClientClass<C>,
  ): C {
    return new $C(contract, this) as C
  }
}

/** Batches transactions and broadcasts them as a single message.
  * - TODO: Break down into multiple batches accorting to fetchLimits */
export abstract class Batch {
  chain:    Chain
  callback: (batch: this) => unknown
  messages: any[]  = []

  constructor (chain: Chain, messages: any[]|Batch["callback"]) {
    this.chain = chain
    if (typeof messages === 'function') {
      this.callback = messages
    } else if (messages instanceof Array) {
      this.messages = messages
    } else if (messages) {
      throw new Error('invalid argument passed to batch')
    }
  }

  log = new Console(this.constructor.name)

  getClient <C extends ContractClient> (...args: Parameters<Chain["getClient"]>): C {
    return this.chain.getClient(...args) as C
  }

  /** Add a message to the batch. */
  add (msg: Message) {
    this.messages.push(msg)
  }

  /** Add an init message to the batch. */
  async instantiate (
    contract: CodeId|Partial<ContractUpload>,
    options: {
      label:     Name,
      initMsg:   Into<Message>,
      initFee?:  unknown,
      initSend?: ICoin[],
      initMemo?: string,
    }
  ): Promise<ContractInstance & {
    address: Address,
  }> {
    if (typeof contract === 'string') {
      contract = new ContractUpload({ codeId: contract })
    }
    this.add({ init: {
      codeId:   contract.codeId,
      codeHash: contract.codeHash,
      label:    options.label,
      msg:      await into(options.initMsg),
      sender:   this.address,
      funds:    options.initSend || [],
      memo:     options.initMemo  || ''
    } })
    return new ContractInstance({
      chainId:  this.agent.chain!.id,
      address:  '(batch not submitted)',
      codeHash: contract.codeHash,
      label:    options.label,
      initBy:   this.address,
    }) as ContractInstance & { address: Address }
  }

  /** Add an exec message to the batch. */
  async execute (
    contract: Address|{ address: Address, codeHash?: CodeHash },
    message:  Message,
    options:  Parameters<Chain["execute"]>[2] = {}
  ): Promise<this> {
    let address: Address
    let codeHash: CodeHash|undefined = undefined
    if (typeof contract === 'string') {
      address = contract
    } else {
      address = contract.address
      codeHash = contract.codeHash
    }
    this.add({
      exec: {
        sender:   this.address,
        contract: address,
        codeHash,
        msg:      message,
        funds:    options.execSend
      }
    })
    return this
  }

  /** Queries are disallowed in the middle of a batch because
    * even though the batch API is structured as multiple function calls,
    * the batch is ultimately submitted as a single transaction and
    * it doesn't make sense to query state in the middle of that. */
  async query <U> (
    contract: Address|{ address: Address, codeHash?: CodeHash },
    msg: Message
  ): Promise<never> {
    throw new Error.Invalid.Batching("query")
  }

  /** Uploads are disallowed in the middle of a batch because
    * it's easy to go over the max request size, and
    * difficult to know what that is in advance. */
  async upload (data: unknown): Promise<never> {
    throw new Error.Invalid.Batching("upload")
  }

  async doUpload (data: unknown): Promise<never> {
    throw new Error.Invalid.Batching("upload")
  }

  /** Uploads are disallowed in the middle of a batch because
    * it's easy to go over the max request size, and
    * difficult to know what that is in advance. */
  async uploadMany (uploadables: Many<unknown> = {}): Promise<never> {
    throw new Error.Invalid.Batching("upload")
  }

  /** Disallowed in batch - do it beforehand or afterwards. */
  get balance (): Promise<string> {
    throw new Error.Invalid.Batching("query balance")
  }
  /** Disallowed in batch - do it beforehand or afterwards. */
  get height (): Promise<number> {
    throw new Error.Invalid.Batching("query block height inside batch")
  }
  /** Disallowed in batch - do it beforehand or afterwards. */
  get nextBlock (): Promise<number> {
    throw new Error.Invalid.Batching("wait for next block")
  }
  /** This doesn't change over time so it's allowed when building batches. */
  getCodeId (address: Address) {
    return this.agent.getCodeId(address)
  }
  /** This doesn't change over time so it's allowed when building batches. */
  getLabel (address: Address) {
    return this.agent.getLabel(address)
  }
  /** This doesn't change over time so it's allowed when building batches. */
  getHash (address: Address|number) {
    return this.agent.getHash(address)
  }
  /** Disallowed in batch - do it beforehand or afterwards. */
  async getBalance (denom: string): Promise<string> {
    throw new Error.Invalid.Batching("query balance")
  }
  /** Disallowed in batch - do it beforehand or afterwards. */
  async send (
    recipient: Address, amounts: ICoin[], options?: Parameters<Chain["send"]>[2]
  ): Promise<void|unknown> {
    throw new Error.Invalid.Batching("send")
  }
  /** Disallowed in batch - do it beforehand or afterwards. */
  async sendMany (
    outputs: [Address, ICoin[]][], options?: Parameters<Chain["sendMany"]>[1]
  ): Promise<void|unknown> {
    throw new Error.Invalid.Batching("send")
  }
  /** Nested batches are "flattened": trying to create a batch
    * from inside a batch returns the same batch. */
  batch <B extends Batch> (cb?: BatchCallback<B>): B {
    if (cb) this.log.warn('Nested batch callback ignored.')
    this.log.warn('Nest batches with care. Depth:', ++this.depth)
    return this as unknown as B
  }

  /** Either submit or save the batch. */
  async run (options: Partial<{
    memo: string,
    save: boolean
  }> = {}): Promise<unknown> {
    if (this.depth > 0) {
      this.log.warn('Unnesting batch. Depth:', --this.depth)
      this.depth--
      return null as any // result ignored
    } else if (options.save) {
      this.log('Saving batch')
      return this.save(options.memo)
    } else {
      this.log('Submitting batch')
      return this.submit(options.memo)
    }
  }

  /** Broadcast a batch to the chain. */
  async submit (memo?: string): Promise<unknown> {
    this.log.warn('Batch#submit: this function is stub; use a subclass of Batch')
    if (memo) this.log.info('Memo:', memo)
    await this.chain.ready
    if (this.callback) await Promise.resolve(this.callback(this))
    this.callback = undefined
    return this.messages.map(()=>({}))
  }

  /** Save a batch for manual broadcast. */
  async save (name?: string): Promise<unknown> {
    this.log.warn('Batch#save: this function is stub; use a subclass of Batch')
    if (name) this.log.info('Name:', name)
    await this.chain.ready
    if (this.callback) await Promise.resolve(this.callback(this))
    this.callback = undefined
    return this.messages.map(()=>({}))
  }

  /** Throws if the batch is invalid. */
  assertMessages (): any[] {
    if (this.messages.length < 1) {
      this.log.emptyBatch()
      throw new Error('Batch contained no messages.')
    }
    return this.messages
  }
}

/** Function passed to Batch#wrap */
export type BatchCallback<B extends Batch> = (batch: B)=>Promise<void>
