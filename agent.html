<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Security-Policy" content="default-src 'self' http: https: ws: wss: 'unsafe-inline';">
<title>Rendered by Ensuite</title>
</head>
<body>
<script data-goatcounter="https://goat.fadroma.hack.bg/count" async src="//goat.fadroma.hack.bg/count.js"></script>
<style name="assets/fonts.css" type="text/css">@font-face {
  font-family: 'Cantarell';
  src: url('fonts/Cantarell-Bold.ttf') format('truetype'),
  url('fonts/Cantarell-Bold.woff') format('woff'),
  url('fonts/Cantarell-Bold.woff2') format('woff2');
  font-weight: 700;
  font-style: normal;
}

@font-face {
  font-family: 'Cantarell';
  src: url('fonts/Cantarell-BoldItalic.ttf') format('truetype'),
  url('fonts/Cantarell-BoldItalic.woff') format('woff'),
  url('fonts/Cantarell-BoldItalic.woff2') format('woff2');
  font-weight: 700;
  font-style: italic;
}

@font-face {
  font-family: 'Cantarell';
  src: url('fonts/Cantarell-ExtraBold.ttf') format('truetype'),
  url('fonts/Cantarell-ExtraBold.woff') format('woff'),
  url('fonts/Cantarell-ExtraBold.woff2') format('woff2');
  font-weight: 800;
  font-style: normal;
}

@font-face {
  font-family: 'Cantarell';
  src: url('fonts/Cantarell-ExtraBoldItalic.ttf') format('truetype'),
  url('fonts/Cantarell-ExtraBoldItalic.woff') format('woff'),
  url('fonts/Cantarell-ExtraBoldItalic.woff2') format('woff2');
  font-weight: 800;
  font-style: italic;
}

@font-face {
  font-family: 'Cantarell';
  src: url('fonts/Cantarell-Italic.ttf') format('truetype'),
  url('fonts/Cantarell-Italic.woff') format('woff'),
  url('fonts/Cantarell-Italic.woff2') format('woff2');
  font-weight: 400;
  font-style: italic;
}

@font-face {
  font-family: 'Cantarell';
  src: url('fonts/Cantarell-Light.ttf') format('truetype'),
  url('fonts/Cantarell-Light.woff') format('woff'),
  url('fonts/Cantarell-Light.woff2') format('woff2');
  font-weight: 300;
  font-style: normal;
}

@font-face {
  font-family: 'Cantarell';
  src: url('fonts/Cantarell-LightItalic.ttf') format('truetype'),
  url('fonts/Cantarell-LightItalic.woff') format('woff'),
  url('fonts/Cantarell-LightItalic.woff2') format('woff2');
  font-weight: 300;
  font-style: italic;
}

@font-face {
  font-family: 'Cantarell';
  src: url('fonts/Cantarell-Regular.ttf') format('truetype'),
  url('fonts/Cantarell-Regular.woff') format('woff'),
  url('fonts/Cantarell-Regular.woff2') format('woff2');
  font-weight: 400;
  font-style: normal;
}

@font-face {
  font-family: 'Cantarell';
  src: url('fonts/Cantarell-Thin.ttf') format('truetype'),
  url('fonts/Cantarell-Thin.woff') format('woff'),
  url('fonts/Cantarell-Thin.woff2') format('woff2');
  font-weight: 200;
  font-style: normal;
}

@font-face {
  font-family: 'Cantarell';
  src: url('fonts/Cantarell-ThinItalic.ttf') format('truetype'),
  url('fonts/Cantarell-ThinItalic.woff') format('woff'),
  url('fonts/Cantarell-ThinItalic.woff2') format('woff2');
  font-weight: 200;
  font-style: italic;
}
</style>
<style name="toolbox/ensuite/node_modules/highlight.js/styles/school-book.css" type="text/css">pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 1em
}
code.hljs {
  padding: 3px 5px
}
/*

School Book style from goldblog.com.ua (c) Zaripov Yura <yur4ik7@ukr.net>

*/
.hljs {
  color: #3e5915;
  background: #f6f5b2
}
.hljs-keyword,
.hljs-selector-tag,
.hljs-literal {
  color: #005599;
  font-weight: bold
}
.hljs-subst {
  color: #3e5915
}
.hljs-string,
.hljs-title,
.hljs-section,
.hljs-type,
.hljs-symbol,
.hljs-bullet,
.hljs-attribute,
.hljs-built_in,
.hljs-addition,
.hljs-variable,
.hljs-template-tag,
.hljs-template-variable,
.hljs-link {
  color: #2c009f
}
.hljs-comment,
.hljs-quote,
.hljs-deletion,
.hljs-meta {
  color: #e60415
}
.hljs-keyword,
.hljs-selector-tag,
.hljs-literal,
.hljs-doctag,
.hljs-title,
.hljs-section,
.hljs-type,
.hljs-name,
.hljs-selector-id,
.hljs-strong {
  font-weight: bold
}
.hljs-emphasis {
  font-style: italic
}</style>
<style name="assets/style.css" type="text/css">* {
  box-sizing: border-box; margin: 0; padding: 0; line-height: 1.5;
}
html, body {
  min-height: 100%; height: 100%
}
body {
  color: #123;
  font-size: 16px;
  font-family: "Cantarell", sans-serif;
  background-color: rgb(101, 179, 76);
  background-image: url('bg.svg');
  background-repeat: repeat;
}
  body > .content {
    display: flex;
    flex-flow: row nowrap;
    align-items: flex-start;
    background: #f0f0f0;
    margin: 1rem;
    border-radius: 1rem;
    box-shadow: 3px 3px 6px rgba(0,0,0,0.1);
  }
  body > .content > header {
    text-align: center;
    margin: 0 auto;
    padding: 2rem 2rem 1rem;
    display: flex;
    flex-flow: column nowrap;
    justify-content: space-around;
    align-items: center;
    max-width: 20rem;
  }
    body > .content > header .logo {
      display: block; margin: 0; flex-shrink: 1;
      margin-bottom: 1rem;
    }
    body > .content > header .logo img {
      display: block;
      margin: 0;
      flex-shrink: 1;
      max-width: 16rem;
      max-height: 16rem;
    }
    body > .content > header a.badge {
      display: inline-block; padding: 0.25rem 0.5rem;
    }

section { padding: 1em; }

footer { padding: 1em; }

a { text-decoration: none; }
a:hover { text-decoration: underline; }
a, a:focus, a:visited, a:active, a:hover { color: rgb(101, 179, 76) }

h1, h2, h3, h4 { font-weight: 600 }
h1 { font-size: 3em;     line-height: 3rem;   margin-bottom: 2rem;                     }
h2 { font-size: 1.75em;  line-height: 2rem;   margin-bottom: 1rem;   margin-top: 0;    }
h3 { font-size: 1.5rem;  line-height: 2rem;   margin-bottom: 1rem;                     }
h4 { font-size: 1.25em;  line-height: 1.5rem; margin-bottom: 0.5rem; margin-top: 2rem; }
h5 { font-size: 1.125em; line-height: 1.5rem; margin-bottom: 0.5rem; margin-top: 2rem; }

button, .button {
  display: inline-block;
  background: rgb(101, 179, 76);
  color: white;
  padding: 0 1em;
  margin: 1em 0;
  text-shadow: -1px -1px 0 black;
  box-shadow: 1px 1px 0 black;
}
a.button:focus, a.button:visited, a.button:active, a.button:hover {
  color: white;
}

th, td { text-align: left; vertical-align: top; }
th { padding-right: 5em }

.row {
  display: flex;
  flex-flow: row nowrap;
  align-items: center;
}
.column {
  display: flex;
  flex-flow: column nowrap;
  align-items: center;
}

.grid {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  flex-flow: row wrap;
  justify-content: center;
  margin: 0 0 3rem 0;
  padding: 0.33rem 0.66rem 0 0;
}

@media (max-width: 80rem) {
  body > .content {
    flex-flow: row wrap;
  }
  .grid {
    display: flex;
    flex-flow: column nowrap;
  }
  .grid .feature {
    display: flex;
    flex-flow: row nowrap;
  }
  .grid .feature .links {
    flex-shrink: 0;
    width: 33%;
    margin: 0 0 0 2rem;
  }
  .table-of-contents {
    width: 1rem;
  }
}

@media (max-width: 48rem) {
  .grid .feature .links {
    width: 50%;
  }
}

.big-left { grid-column-start: 1; grid-column-end: 3; }
.big-center { grid-column-start: 2; grid-column-end: 4; }
.big-right { grid-column-start: 3; grid-column-end: 5; }
.big-all { grid-column-start: 1; grid-column-end: 5; }

.feature {
  padding: 1rem;
  margin: 1rem 0.66rem 0;
  border: 1px solid rgba(0,0,0,0.1);
  border-top-color: rgba(255,255,255,0.5);
  border-left-color: rgba(255,255,255,0.5);
  border-radius: 3px;
  box-shadow: 3px 3px 6px rgba(0,0,0,0.1);
  display: flex;
  flex-flow: column nowrap;
  background: #fff;
  min-height: 10rem;
  border-radius: 0.5rem;
}
  .feature .docs {
    font-weight: bold;
  }
  .feature .description {
    line-height: 1.5;
    font-size: 0.875rem;
  }

.left {
  text-align: left;
}
.center {
  text-align: center;
}


code { font-size: 0.9375rem; }
code.inline, code.block { background: #0c5749; color: white; font-family: monospace; font-weight: bold; }
code.inline { display: inline-block; padding: 0.5rem 1rem; margin: 0 0.5rem; }
code.block {
  display: block;
  padding: 1rem;
  margin: 1rem auto;
  border-radius: 0.5rem;
  max-width: 40rem;
  line-height: 1rem;
}

.feature-logo {
  margin-bottom: 0.5rem;
  height:        5rem;
  width:         12rem;
  align-self:    center;
}

.tag {
  font-size: 0.8rem;
  background: #f5faf3;
  border: 1px solid #437733;
  color: #437733;
  display: inline-block;
  padding: 0.25rem 0.5rem;
  margin: 0.5rem 0 0;
  align-self: flex-start;
  border-radius: 3px;
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.spacer {
  flex-grow:  1;
  min-height: 0.5rem;
}

pre, code {
  font-family: monospace;
}

p {
  line-height: 1.75rem;
  margin-top: 0;
  margin-bottom: 0.5rem;
  font-size: 1rem;
}

svg.icon {
  width: 2rem;
  height: 2rem;
}
a > svg.icon {
  fill: rgb(101, 179, 76);
  width: 1.5rem;
  height: 1.5rem;
  line-height: 1rem;
  vertical-align: baseline;
  margin-right: 0.5rem;
  flex-shrink: 0;
}
.feature a.docs {
  display: flex;
  flex-flow: row nowrap;
  align-items: flex-start;
  font-weight: normal;
  text-decoration: none;
  padding: 0.5rem 0;
  cursor: default;
  color: #888;
}
.feature a.docs[href] {
  text-decoration: underline;
  color: rgb(67, 119, 51);
  cursor: pointer;
}

@keyframes hourglass {
  50%  { transform: rotateZ(0);      }
	100% { transform: rotateZ(180deg); }
}

svg.icon-todo {
  animation-name: hourglass;
  animation-duration: 3s;
  animation-delay: 1s;
  animation-iteration-count: infinite;
}

.links {
  display: flex;
  flex-flow: column nowrap;
}
.links > a {
  margin-right: 1rem;
  transition:
    padding-left 0.33s,
    margin-right 0.33s;
}
.links > a[href]:hover {
  padding-left: 0.5rem;
  margin-right: 0.5rem;
}
.feature pre {
  background: #eee;
  padding: 0.5rem;
  border-radius: 0.1rem;
  font-size: 0.875rem;
  font-weight: normal;
  margin-top: 1rem;
  color: #555;
}

/*.feature .links .icon { fill: #F46623 }*/

.feature.invert { background: rgb(67, 119, 51); color: white; }
.feature.invert * { color: white; fill: white; }
.feature.invert a.docs { color: white; }
.feature.invert a.docs[href] { text-decoration: underline; }

.feature.foss { background: #2e0056; color: white; }
.feature.foss * { color: white; fill:  white; }
.feature.foss a.docs { color: white; }

.icon-todo { fill: #aaa !important; }

#quick-start {
  text-align: center;
  flex-grow: 1;
}

.ensuite-md-rendered {
  /*background: white;*/
  /*display: block;*/
  /*max-width: 54rem;*/
  /*margin: 3rem auto 0 38%;*/
  /*padding: 3rem;*/
  /*box-shadow: 3px 3px 6px rgba(0,0,0,0.1)*/
  display: flex;
  flex-flow: row nowrap;
  justify-content: center;
}


.ensuite-md-content {
  background: white;
  padding:    5rem 3rem 2rem;
  box-shadow: 3px 3px 6px rgba(0,0,0,0.1);
  max-width:  54rem;
}

.ensuite-md-nav {}
.ensuite-md-nav ul { list-style: none; margin-top: 5rem; margin-right: 2rem; }
.ensuite-md-nav li a { display: inline-block; font-weight: bold; padding: 0.5rem 1rem; text-transform: uppercase; font-size: 0.9rem; line-height: 1rem }

.ensuite-md-toc {}
.ensuite-md-toc .table-of-contents { margin-top: 5rem; margin-left: 1rem; overflow: auto; }
.table-of-contents { overflow: auto }
.table-of-contents a { display: block; text-decoration: none; padding: 0.25rem 1.5rem 0.25rem }
.table-of-contents a:hover { text-decoration: underline 2px solid }
.table-of-contents li { margin: 0 0 }
.table-of-contents ul { font-weight: bold; margin-left: 0; list-style: none }
.table-of-contents ul ul { font-weight: normal; margin-left: 1em }


/*.ensuite-md-rendered .table-of-contents {*/
  /*position: fixed;*/
  /*top: 3rem;*/
  /*left: 0;*/
  /*bottom: 0;*/
  /*width: 38%;*/
  /*background: #476d3b;*/
  /*background: hsl(106 25% 25% / 1);*/
  /*color: white;*/
  /*padding: 1rem 0 2rem 1rem;*/
  /*border-right: 1px solid #888;*/
  /*display: flex;*/
  /*justify-content: flex-end;*/
/*}*/
.ensuite-md-rendered h2 { margin-top: 2.5rem; margin-bottom: 0.5rem; }
.ensuite-md-rendered h3 { margin-top: 1.5rem; margin-bottom: 0.5rem; }

ul { margin-left: 0; margin-bottom: 1em; }

p > code { font-weight: bold; color: #345 }
pre > code {
  display: block;
  border: 1px solid #888;
  padding: 0.5rem 1rem;
  margin-bottom: 1rem;
  background: rgba(255,255,255,0.5);
  box-shadow: 2px 2px 2px #888;
  overflow-x: auto;
  margin: 1rem -1rem;
}
pre > code.language-sh {
  background: #123;
  border-radius: 0;
  color: #fe0;
}
pre > code.language-typescript {
  background: #ffe;
  border-radius: 0.15rem;
}

.ensuite-md-header {
  z-index: 100;
  display: flex;
  flex-flow: row nowrap;
  justify-content: space-between;
  text-align: left;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 3rem;
  font-size: 1.5rem;
  line-height: 3rem;
  margin: 0;
  padding: 0 1rem;
  font-weight: bold;
  background: hsl(106 30% 33% / 1);
  color: white;
  width: 100%;
  max-width: 100%;
  font-weight: normal
}
.ensuite-md-separator {
  flex-grow: 1;
}
.ensuite-md-header a {
  color: white;
}
.ensuite-md-header .ensuite-md-title {
}
.ensuite-md-header .ensuite-md-link {
  font-size: 1rem;
  margin-left: 1rem;
}

.hljs-comment, .hljs-deletion, .hljs-meta, .hljs-quote {
  color: green;
}
.hljs.language-sh .hljs-built_in {
  color: inherit;
}
.hljs.language-sh .hljs-comment {
  color: tomato;
}

hr {
  margin: 1rem -1rem;
}
</style>
<header class="ensuite-md-header">
<a class="ensuite-md-title" href="/">The <strong>Fadroma</strong> Guide</a>
<div class="ensuite-md-separator"></div>
<a class="ensuite-md-link" href=/>Homepage</a>
<a class="ensuite-md-link" href=/guide.html>Documentation</a>
<a class="ensuite-md-link" href=https://github.com/hackbg/fadroma>Github</a>
<a class="ensuite-md-link" href=https://crates.io/search?q=fadroma>Crates.io</a>
<a class="ensuite-md-link" href=https://www.npmjs.com/search?q=fadroma>NPM</a>
<a class="ensuite-md-link" href=https://hack.bg/>Hack.bg</a>
</header>
<div class="ensuite-md-rendered">
<nav class="ensuite-md-nav"><ul>
<li><a class="ensuite-md-link" href=/guide.html>Getting started</a></li>
<li><a class="ensuite-md-link" href=/project.html>Projects</a></li>
<li><a class="ensuite-md-link" href=/agent.html>Agent API</a></li>
<li><a class="ensuite-md-link" href=/scrt.html>Secret Network</a></li>
<li><a class="ensuite-md-link" href=/dsl.html>Macro DSL</a></li>
<li><a class="ensuite-md-link" href=/build.html>Building</a></li>
<li><a class="ensuite-md-link" href=/upload.html>Uploading</a></li>
<li><a class="ensuite-md-link" href=/deploy.html>Deploy API</a></li>
<li><a class="ensuite-md-link" href=/factory.html>Factories</a></li>
<li><a class="ensuite-md-link" href=/devnet.html>Devnets</a></li>
<li><a class="ensuite-md-link" href=/mocknet.html>Mocknets</a></li>
<li><a class="ensuite-md-link" href=/impl.html>Supporting new chains</a></li>
</ul></nav>
<content class="ensuite-md-content"><div><p></div></p>
<h1 id="fadroma-agent%3A-scriptable-user-agents-for-the-blockchain" tabindex="-1"><a href="https://fadroma.tech">Fadroma</a> Agent: Scriptable User Agents for the Blockchain</h1>
<p><a href="https://www.npmjs.com/package/@fadroma/agent"><img src="https://img.shields.io/npm/v/@fadroma/agent?color=%2365b34c&amp;label=%40fadroma%2Fagent&amp;style=for-the-badge" alt=""></a></p>
<p>The <em>Fadroma Agent API</em> is Fadroma's imperative API for interacting with smart contract
platforms. It's designed for expressing smart contract operations in a concise and readable manner.</p>
<p>The API is specified by the <a href="https://www.npmjs.com/package/@fadroma/agent"><strong>@fadroma/agent</strong></a>
package. In effect, it's a reduced and simplified vocabulary that covers the common ground
between different implementations of smart contract-enabled chains.</p>
<p>Since different chains provide different client libraries and connection methods,
the concrete implementations of the Fadroma Agent API are contained in separate
packages:</p>
<ul>
<li><a href="https://www.npmjs.com/package/@fadroma/scrt"><strong>@fadroma/scrt</strong></a> for Secret Network;</li>
<li><a href="https://www.npmjs.com/package/@fadroma/cw"><strong>@fadroma/cw</strong></a> for other CosmWasm-enabled chains,
such as OKP4.</li>
</ul>
<p><a href="https://www.npmjs.com/package/@fadroma/connect"><strong>@fadroma/connect</strong></a> reexports all available
Fadroma Agent API implementations. It's recommended to use <strong>@fadroma/connect</strong> when depending
on more than one of the above.</p>
<p>The overarching goal of Fadroma Agent is to enable developers to learn only a single client
library for all supported blockchains and client platforms.</p>
<h2 id="connecting-to-a-chain" tabindex="-1">Connecting to a chain</h2>
<p>Instances of the <strong>Chain</strong> class represents blockchains.</p>
<p>A chain may exists in one of several modes,
represented by the <strong>chain.mode</strong> property
and the <strong>ChainMode</strong> enum:</p>
<ul>
<li><strong><strong>mainnet</strong></strong> is a production chain storing real value;</li>
<li><strong><strong>testnet</strong></strong> is a persistent remote chain used for testing;</li>
<li><strong><strong>devnet</strong></strong> is a locally run chain node in a Docker container;</li>
<li><strong><strong>mocknet</strong></strong> is a mock implementation of a chain.</li>
</ul>
<p>The <strong>Chain.mainnet</strong>, <strong>Chain.testnet</strong>, <strong>Chain.devnet</strong> and <strong>Chain.mocknet</strong>
static methods construct a chain in the given mode.</p>
<p>You can also check whether a chain is in a given mode using the
<strong>chain.isMainnet</strong>, <strong>chain.isTestnet</strong>, <strong>chain.isDevnet</strong> and <strong>chain.isMocknet</strong>
read-only boolean properties.</p>
<p>The <strong>chain.devMode</strong> property is true when the chain is a devnet or mocknet.
Devnets and mocknets are under your control - i.e. you can delete them and
start over. On the other hand, mainnet and testnet are global and persistent.</p>
<p>The <strong>chain.id</strong> property is a string that uniquely identifies a given blockchain.
Examples are <code>secret-4</code> (Secret Network mainnet), <code>pulsar-3</code> (Secret Network testnet),
or <code>okp4-nemeton-1</code> (OKP4 testnet). Chains in different modes usually have distinct IDs.</p>
<p>The same chain may be accessible via different URLs. The <strong>chain.url</strong> property
identifies the URL to which requests are sent.</p>
<p>Since the underlying API classes (e.g. <code>CosmWasmClient</code> or <code>SecretNetworkClient</code>) are
initialized asynchronously, and JavaScript does not have async constructors, chains start
out in an unitialized state, where the <strong>chain.api</strong> property is not populated. Awaiting the
<strong>chain.ready</strong> one-shot promise returns the same chain object, but with the API client populated.
Normally, this is done automatically when calling the chain's async methods; but if you want to
access the API handle directly, you would need to <strong>await chain.ready</strong>. This is useful if you
want to access a chain-specific feature that is not part of the Fadroma Agent API</p>
<p>Examples:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> { api } = <span class="hljs-keyword">await</span> chain.<span class="hljs-property">ready</span>
</code></pre>
<h3 id="block-height" tabindex="-1">Block height</h3>
<p>The <strong>chain.height</strong> getter returns a <strong>Promise</strong> wrapping the current block height.</p>
<p>The <strong>chain.nextBlock</strong> getter returns a <strong>Promise</strong> which resolves when the
block height increments, and contains the new block height.</p>
<p>Examples:</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// Get the current block height</span>
<span class="hljs-keyword">const</span> height = <span class="hljs-keyword">await</span> chain.<span class="hljs-property">height</span>

<span class="hljs-comment">// Wait until the block height increments</span>
<span class="hljs-keyword">await</span> chain.<span class="hljs-property">nextBlock</span>
</code></pre>
<h3 id="native-tokens" tabindex="-1">Native tokens</h3>
<p>The <strong>Chain.defaultDenom</strong> and <strong>chain.defaultDenom</strong> properties contain the default
denomination of the chain's native token.</p>
<p>The <strong>chain.getBalance(denom, address)</strong> async method queries the balance of a given
address in a given token.</p>
<p>Examples:</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// TODO</span>
</code></pre>
<h3 id="querying-contracts" tabindex="-1">Querying contracts</h3>
<p>The <strong>chain.query(contract, message)</strong> async method calls a read-only query method of a smart
contract.</p>
<p>The <strong>chain.getCodeId(address)</strong>, <strong>chain.getHash(addressOrCodeId)</strong> and
<strong>chain.getLabel(address)</strong> async methods query the corresponding metadata of a smart contract.</p>
<p>The <strong>chain.checkHash(address, codeHash)</strong> method warns if the code hash of a contract
is not the expected one.</p>
<p>Examples:</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// TODO</span>
</code></pre>
<h2 id="authenticating-an-agent" tabindex="-1">Authenticating an agent</h2>
<p>To transact on a given chain, you need to authorize an <strong>Agent</strong>.
This is done using the <strong>chain.authenticate(...)</strong> method, which synchonously
returns a new <strong>Agent</strong> instance for the given chain.</p>
<p>Instantiating multiple agents allows the same program to interact with the chain
from multiple distinct identities.</p>
<p>This method may be called with one of the following signatures:</p>
<ul>
<li><strong>chain.authenticate(options)</strong></li>
<li><strong>chain.authenticate(CustomAgentClass, options)</strong></li>
<li><strong>chain.authenticate(CustomAgentClass)</strong></li>
</ul>
<p>The returned <strong>Agent</strong> starts out uninitialized. Awaiting the <strong>agent.ready</strong> property makes sure
the agent is initialized. Usually, agents are initialized the first time you call one of the
async methods described below.</p>
<p>If you don't pass a mnemonic, a random mnemonic and address will be generated.</p>
<p>Examples:</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// TODO</span>
</code></pre>
<h3 id="agent-identity" tabindex="-1">Agent identity</h3>
<p>The <strong>agent.address</strong> property is the on-chain address that uniquely identifies the agent.</p>
<p>The <strong>agent.name</strong> property is a user-friendly name for an agent. On devnet, the name is
also used to access the initial accounts that are created during devnet genesis.</p>
<h3 id="agents-and-block-height" tabindex="-1">Agents and block height</h3>
<p>The <strong>agent.height</strong> and <strong>agent.nextBlock</strong> methods are equivalent to the same methods
on the chain object, and are replicated on the Agent class purely for convenience.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> height = <span class="hljs-keyword">await</span> agent.<span class="hljs-property">height</span>

<span class="hljs-keyword">await</span> agent.<span class="hljs-property">nextBlock</span>
</code></pre>
<h3 id="native-token-transactions" tabindex="-1">Native token transactions</h3>
<p>The <strong>agent.getBalance(denom, address)</strong> async method works the same as <strong>chain.getBalance(...)</strong>
but defaults to the agent's address.</p>
<p>The <strong>agent.balance</strong> readonly property is a shorthand for querying the current agent's balance
in the chain's main native token.</p>
<p>The <strong>agent.send(address, amounts, options)</strong> async method sends one or more amounts of
native tokens to the specified address.</p>
<p>The <strong>agent.sendMany([[address, coin], [address, coin]...])</strong> async method sends native tokens
to multiple addresses.</p>
<p>Examples:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">await</span> agent.<span class="hljs-property">balance</span> <span class="hljs-comment">// In the default native token</span>

<span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">getBalance</span>() <span class="hljs-comment">// In the default native token</span>

<span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">getBalance</span>(<span class="hljs-string">&#x27;token&#x27;</span>) <span class="hljs-comment">// In a non-default native token</span>

<span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;recipient-address&#x27;</span>, <span class="hljs-number">1000</span>)

<span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;recipient-address&#x27;</span>, <span class="hljs-string">&#x27;1000&#x27;</span>)

<span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;recipient-address&#x27;</span>, [
  {<span class="hljs-attr">denom</span>:<span class="hljs-string">&#x27;token1&#x27;</span>, <span class="hljs-attr">amount</span>: <span class="hljs-string">&#x27;1000&#x27;</span>}
  {<span class="hljs-attr">denom</span>:<span class="hljs-string">&#x27;token2&#x27;</span>, <span class="hljs-attr">amount</span>: <span class="hljs-string">&#x27;2000&#x27;</span>}
])
</code></pre>
<h3 id="uploading-and-instantiating-contracts" tabindex="-1">Uploading and instantiating contracts</h3>
<p>The <strong>agent.upload(...)</strong> uploads a contract binary to the chain.</p>
<p>The <strong>agent.instantiate(...)</strong> async method takes a code ID and returns a contract
instance.</p>
<p>The <strong>agent.instantiateMany(...)</strong> async method instantiates multiple contracts within
the same transaction.</p>
<p>On Secret Network, it's not possible to send multiple separate upload transactions
within the same block. Therefore, when uploading multiple contracts, <strong>agent.nextBlock</strong>
needs to be awaited between them. <strong>agent.uploadMany(...)</strong> does this automatically.</p>
<p>Examples:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { examples } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./fixtures/Fixtures.ts.md&#x27;</span>
<span class="hljs-keyword">import</span> { readFileSync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:fs&#x27;</span>

<span class="hljs-comment">// uploading from a Buffer</span>
<span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">upload</span>(<span class="hljs-title function_">readFileSync</span>(examples[<span class="hljs-string">&#x27;KV&#x27;</span>].<span class="hljs-property">path</span>), {
  <span class="hljs-comment">// optional metadata</span>
  <span class="hljs-attr">codePath</span>: examples[<span class="hljs-string">&#x27;KV&#x27;</span>].<span class="hljs-property">path</span>
})

<span class="hljs-comment">// Uploading from a filename</span>
<span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">upload</span>(<span class="hljs-string">&#x27;example.wasm&#x27;</span>) <span class="hljs-comment">// TODO</span>

<span class="hljs-comment">// Uploading an Uploadable object</span>
<span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">upload</span>({ <span class="hljs-attr">artifact</span>: <span class="hljs-string">&#x27;./example.wasm&#x27;</span>, <span class="hljs-attr">codeHash</span>: <span class="hljs-string">&#x27;expectedCodeHash&#x27;</span> }) <span class="hljs-comment">// TODO</span>

<span class="hljs-keyword">const</span> c1 = <span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">instantiate</span>({
  <span class="hljs-attr">codeId</span>:   <span class="hljs-string">&#x27;1&#x27;</span>,
  <span class="hljs-attr">codeHash</span>: <span class="hljs-string">&#x27;verify!&#x27;</span>,
  <span class="hljs-attr">label</span>:    <span class="hljs-string">&#x27;unique1&#x27;</span>,
  <span class="hljs-attr">initMsg</span>:  { <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;val&#x27;</span> }
})

<span class="hljs-keyword">const</span> [ c2, c3 ] = <span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">instantiateMany</span>([
  { <span class="hljs-attr">codeId</span>: <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;unique2&#x27;</span>, <span class="hljs-attr">initMsg</span>: { <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;values&#x27;</span> } },
  { <span class="hljs-attr">codeId</span>: <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;unique3&#x27;</span>, <span class="hljs-attr">initMsg</span>: { <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;values&#x27;</span> } }
])
</code></pre>
<h3 id="executing-transactions-and-performing-queries" tabindex="-1">Executing transactions and performing queries</h3>
<p>The <strong>agent.query(contract, message)</strong> async method calls a query method of a smart contract.
This is equivalent to <strong>chain.query(...)</strong>.</p>
<p>The <strong>agent.execute(contract, message)</strong> async method calls a transaction method of a smart
contract, signing the transaction as the given agent.</p>
<p>Examples:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">query</span>(c1, { <span class="hljs-attr">get</span>: { <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;1&#x27;</span> } })
assert.<span class="hljs-title function_">rejects</span>(agent.<span class="hljs-title function_">query</span>(c1, { <span class="hljs-attr">invalid</span>: <span class="hljs-string">&quot;query&quot;</span> }))

<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">execute</span>(c1, { <span class="hljs-attr">set</span>: { <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;2&#x27;</span> } })
assert.<span class="hljs-title function_">rejects</span>(agent.<span class="hljs-title function_">execute</span>(c1, { <span class="hljs-attr">invalid</span>: <span class="hljs-string">&quot;tx&quot;</span> }))
</code></pre>
<h3 id="batching-transactions" tabindex="-1">Batching transactions</h3>
<p>The <strong>agent.batch(...)</strong> method creates an instance of <strong>Batch</strong>.</p>
<p>Conceptually, you can view a batch as a kind of agent that does not execute transactions
immediately - it collects them, and waits for the <strong>batch.broadcast()</strong> method. You can
pass a batch anywhere you can pass an agent.</p>
<p>The main difference between a batch and and agent is that <em>you cannot query from a batch</em>.
This is because a batch is an atomic action, and queries made inbetween individual transactions
of a batch would return the state as it was before <em>all</em> the transactions. Therefore, to avoid
confusion and outdated state, the query methods of the batch &quot;agent&quot; throw errors.
If you need to perform queries, use a regular agent before or after the batch.</p>
<p>Instead of broadcasting, you can also export an unsigned batch, and pass it around manually
as part of a multisig transaction.</p>
<p>To create and submit a batch in a single expression,
you can use <code>batch.wrap(async (batch) =&gt; { ... })</code>:</p>
<p>Examples:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">batch</span>(<span class="hljs-keyword">async</span> batch=&gt;{
  <span class="hljs-keyword">await</span> batch.<span class="hljs-title function_">execute</span>(c1, { <span class="hljs-attr">del</span>: { <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;1&#x27;</span> } })
  <span class="hljs-keyword">await</span> batch.<span class="hljs-title function_">execute</span>(c2, { <span class="hljs-attr">set</span>: { <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;4&#x27;</span> } })
}).<span class="hljs-title function_">run</span>()
</code></pre>
<h2 id="gas-fees" tabindex="-1">Gas fees</h2>
<p>Transacting creates load on the network, which incurs costs on node operators.
Compensations for transactions are represented by the gas metric.</p>
<p>You can specify default gas limits for each method by defining the <code>fees: Record&lt;string, IFee&gt;</code>
property of your client class:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> fee1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fee</span>(<span class="hljs-string">&#x27;100000&#x27;</span>, <span class="hljs-string">&#x27;uscrt&#x27;</span>)
client.<span class="hljs-property">fees</span>[<span class="hljs-string">&#x27;my_method&#x27;</span>] = fee1

assert.<span class="hljs-title function_">deepEqual</span>(client.<span class="hljs-title function_">getFee</span>(<span class="hljs-string">&#x27;my_method&#x27;</span>), fee1)
assert.<span class="hljs-title function_">deepEqual</span>(client.<span class="hljs-title function_">getFee</span>({<span class="hljs-string">&#x27;my_method&#x27;</span>:{<span class="hljs-string">&#x27;parameter&#x27;</span>:<span class="hljs-string">&#x27;value&#x27;</span>}}), fee1)
</code></pre>
<p>You can also specify one fee for all transactions, using <code>client.withFee({ gas, amount: [...] })</code>.
This method works by returning a copy of <code>client</code> with fees overridden by the provided value.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> fee2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fee</span>(<span class="hljs-string">&#x27;200000&#x27;</span>, <span class="hljs-string">&#x27;uscrt&#x27;</span>)

assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-keyword">await</span> client.<span class="hljs-title function_">withFee</span>(fee2).<span class="hljs-title function_">getFee</span>(<span class="hljs-string">&#x27;my_method&#x27;</span>), fee2)
</code></pre>
<h2 id="contracts" tabindex="-1">Contracts</h2>
<h3 id="contract-clients" tabindex="-1">Contract clients</h3>
<p>The <strong>Client</strong> class represents a handle to a smart contract deployed to a given chain.</p>
<p>To provide a robust SDK to users of your project, simply publish a NPM package
containing subclasses of <strong>Client</strong> that correspond to your contracts and invoke
their methods.</p>
<p>To operate a smart contract through a <code>Client</code>,
you need an <code>agent</code>, an <code>address</code>, and a <code>codeHash</code>:</p>
<p>Example:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Client</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fadroma/agent&#x27;</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Client</span> {

  myMethod = <span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">execute</span>({
    <span class="hljs-attr">my_method</span>: { param }
  })

  myQuery = <span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">query</span>({
    <span class="hljs-attr">my_query</span>: { param }
  })

}

<span class="hljs-keyword">let</span> address  = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;some-addr&#x27;</span>)
<span class="hljs-keyword">let</span> codeHash = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;some-hash&#x27;</span>)
<span class="hljs-keyword">let</span> <span class="hljs-attr">client</span>: <span class="hljs-title class_">Client</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClient</span>({ agent, address, codeHash })

assert.<span class="hljs-title function_">equal</span>(client.<span class="hljs-property">agent</span>,    agent)
assert.<span class="hljs-title function_">equal</span>(client.<span class="hljs-property">address</span>,  address)
assert.<span class="hljs-title function_">equal</span>(client.<span class="hljs-property">codeHash</span>, codeHash)
client = agent.<span class="hljs-title function_">getClient</span>(<span class="hljs-title class_">MyClient</span>, address, codeHash)
<span class="hljs-keyword">await</span> client.<span class="hljs-title function_">execute</span>({ <span class="hljs-attr">my_method</span>: {} })
<span class="hljs-keyword">await</span> client.<span class="hljs-title function_">query</span>({ <span class="hljs-attr">my_query</span>: {} })
</code></pre>
<h4 id="client-agent" tabindex="-1">Client agent</h4>
<p>By default, the <code>Client</code>'s <code>agent</code> property is equal to the <code>agent</code>
which deployed the contract. This property determines the address from
which subsequent transactions with that <code>Client</code> will be sent.</p>
<p>In case you want to deploy the contract as one identity, then interact
with it from another one as part of the same procedure, you can set <code>agent</code>
to another instance of <code>Agent</code>:</p>
<pre><code class="hljs language-typescript">assert.<span class="hljs-title function_">equal</span>(client.<span class="hljs-property">agent</span>, agent)
client.<span class="hljs-property">agent</span> = <span class="hljs-keyword">await</span> chain.<span class="hljs-title function_">authenticate</span>()
assert.<span class="hljs-title function_">notEqual</span>(client.<span class="hljs-property">agent</span>, agent)
</code></pre>
<p>Similarly to <code>withFee</code>, the <code>as</code> method returns a new instance of your
client class, bound to a different <code>agent</code>, thus allowing you to execute
transactions as a different identity.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> agent1 = <span class="hljs-keyword">await</span> chain.<span class="hljs-title function_">authenticate</span>(<span class="hljs-comment">/*...*/</span>)
<span class="hljs-keyword">const</span> agent2 = <span class="hljs-keyword">await</span> chain.<span class="hljs-title function_">authenticate</span>(<span class="hljs-comment">/*...*/</span>)

client = agent1.<span class="hljs-title function_">getClient</span>(<span class="hljs-title class_">Client</span>, <span class="hljs-string">&quot;...&quot;</span>)

<span class="hljs-comment">// executed by agent1:</span>
client.<span class="hljs-title function_">execute</span>({ <span class="hljs-attr">my_method</span>: {} })

<span class="hljs-comment">// executed by agent2</span>
client.<span class="hljs-title function_">withAgent</span>(agent2).<span class="hljs-title function_">execute</span>({ <span class="hljs-attr">my_method</span>: {} })
</code></pre>
<h4 id="client-metadata" tabindex="-1">Client metadata</h4>
<p>The original <code>Contract</code> object from which the contract
was deployed can be found on the optional <code>meta</code> property of the <code>Client</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Contract</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@hackbg/fadroma&#x27;</span>
assert.<span class="hljs-title function_">ok</span>(client.<span class="hljs-property">meta</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Contract</span>)
</code></pre>
<p>Fetching metadata:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { fetchLabel } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fadroma/agent&#x27;</span>

<span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchCodeId</span>(client, agent)
<span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchLabel</span>(client, agent)
</code></pre>
<p>The code ID is a unique identifier for compiled code uploaded to a chain.</p>
<p>The code hash also uniquely identifies for the code that underpins a contract.
However, unlike the code ID, which is opaque, the code hash corresponds to the
actual content of the code. Uploading the same code multiple times will give
you different code IDs, but the same code hash.</p>
<h3 id="contract-deployments" tabindex="-1">Contract deployments</h3>
<p>These classes are used for describing systems consisting of multiple smart contracts,
such as when deploying them from source. By defining such a system as one or more
subclasses of <code>Deployment</code>, Fadroma enables declarative, idempotent, and reproducible
smart contract deployments.</p>
<p>The <code>Deployment</code> class represents a set of interrelated contracts.
To define your deployment, extend the <code>Deployment</code> class, and use the
<code>this.template({...})</code> and <code>this.contract({...})</code> methods to specify
what contracts to deploy:</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// in your project&#x27;s api.ts:</span>

<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Deployment</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fadroma/agent&#x27;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeploymentA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Deployment</span> {

  kv1 = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">contract</span>({
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kv1&#x27;</span>,
    <span class="hljs-attr">crate</span>: <span class="hljs-string">&#x27;examples/kv&#x27;</span>,
    <span class="hljs-attr">initMsg</span>: {}
  })

  kv2 = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">contract</span>({
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kv2&#x27;</span>,
    <span class="hljs-attr">crate</span>: <span class="hljs-string">&#x27;examples/kv&#x27;</span>,
    <span class="hljs-attr">initMsg</span>: {}
  })

}
</code></pre>
<h4 id="preparing" tabindex="-1">Preparing</h4>
<p>To prepare a deployment for deploying, use <code>getDeployment</code>.
This will provide a populated instance of your deployment class.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { getDeployment } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@hackbg/fadroma&#x27;</span>
deployment = <span class="hljs-title function_">getDeployment</span>(<span class="hljs-title class_">DeploymentA</span>, <span class="hljs-comment">/* ...constructor args */</span>)
</code></pre>
<h4 id="deploying-everything" tabindex="-1">Deploying everything</h4>
<p>Then, call its <code>deploy</code> method:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">await</span> deployment.<span class="hljs-title function_">deploy</span>()
</code></pre>
<p>For each contract defined in the deployment, this will do the following:</p>
<ul>
<li>If it's not compiled yet, this will <strong>build</strong> it.</li>
<li>If it's not uploaded yet, it will <strong>upload</strong> it.</li>
<li>If it's not instantiated yet, it will <strong>instantiate</strong> it.</li>
</ul>
<h4 id="expecting-contracts-to-be-deployed" tabindex="-1">Expecting contracts to be deployed</h4>
<p>Having deployed a contract, you want to obtain a <code>Client</code> instance
that points to it, so you can call the contract's methods.</p>
<p>Using the <code>contract.expect()</code> method you can get an instance
of the <code>Client</code> specified in the contract options, provided
the contract is already deployed (i.e. its address is known).</p>
<pre><code class="hljs language-typescript"><span class="hljs-title function_">assert</span>(deployment.<span class="hljs-property">kv1</span>.<span class="hljs-title function_">expect</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Client</span>)
<span class="hljs-title function_">assert</span>(deployment.<span class="hljs-property">kv2</span>.<span class="hljs-title function_">expect</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Client</span>)
</code></pre>
<p>This is the recommended method for passing handles to contracts
to your UI code after deploying or connecting to a stored deployment
(see below).</p>
<p>If the address of the request contract is not available,
this will throw an error.</p>
<h4 id="deploying-individual-contracts-with-dependencies" tabindex="-1">Deploying individual contracts with dependencies</h4>
<p>By <code>await</code>ing a <code>Contract</code>'s <code>deployed</code> property, you say:
&quot;give me a handle to this contract; if it's not deployed,
deploy it, and all of its dependencies (as specified by the <code>initMsg</code> method)&quot;.</p>
<pre><code class="hljs language-typescript"><span class="hljs-title function_">assert</span>(<span class="hljs-keyword">await</span> deployment.<span class="hljs-property">kv1</span>.<span class="hljs-property">deployed</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Client</span>)
<span class="hljs-title function_">assert</span>(<span class="hljs-keyword">await</span> deployment.<span class="hljs-property">kv2</span>.<span class="hljs-property">deployed</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Client</span>)
</code></pre>
<p>Since this does not call the deployment's <code>deploy</code> method,
it <em>only</em> deploys the requested contract and its dependencies
but not any other contracts defined in the deployment.</p>
<h4 id="deploying-with-custom-logic" tabindex="-1">Deploying with custom logic</h4>
<p>The <code>deployment.deploy</code> method simply instantiates
all contracts in order. You are free to override it
and deploy the defined contracts according to some
custom logic:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeploymentB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Deployment</span> {
  kv1 = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">contract</span>({ <span class="hljs-attr">crate</span>: <span class="hljs-string">&#x27;examples/kv&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kv1&#x27;</span>, <span class="hljs-attr">initMsg</span>: {} })
  kv2 = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">contract</span>({ <span class="hljs-attr">crate</span>: <span class="hljs-string">&#x27;examples/kv&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kv2&#x27;</span>, <span class="hljs-attr">initMsg</span>: {} })

  deploy = <span class="hljs-keyword">async</span> (<span class="hljs-attr">deployBoth</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>) =&gt; {
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">kv1</span>.<span class="hljs-property">deployed</span>
    <span class="hljs-keyword">if</span> (deployBoth) <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">kv2</span>.<span class="hljs-property">deployed</span>
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
  }
}
</code></pre>
<h3 id="contract-instances" tabindex="-1">Contract instances</h3>
<p>The <code>Contract</code> class describes an individual smart contract instance and uniquely identifies it
within the <code>Deployment</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Contract</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fadroma/agent&#x27;</span>

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Contract</span>({
  <span class="hljs-attr">repository</span>: <span class="hljs-string">&#x27;REPO&#x27;</span>,
  <span class="hljs-attr">revision</span>:   <span class="hljs-string">&#x27;REF&#x27;</span>,
  <span class="hljs-attr">workspace</span>:  <span class="hljs-string">&#x27;WORKSPACE&#x27;</span>
  <span class="hljs-attr">crate</span>:      <span class="hljs-string">&#x27;CRATE&#x27;</span>,
  <span class="hljs-attr">artifact</span>:   <span class="hljs-string">&#x27;ARTIFACT&#x27;</span>,
  <span class="hljs-attr">chain</span>:      { <span class="hljs-comment">/* ... */</span> },
  <span class="hljs-attr">agent</span>:      { <span class="hljs-comment">/* ... */</span> },
  <span class="hljs-attr">deployment</span>: { <span class="hljs-comment">/* ... */</span> },
  <span class="hljs-attr">codeId</span>:     <span class="hljs-number">0</span>,
  <span class="hljs-attr">codeHash</span>:   <span class="hljs-string">&#x27;CODEHASH&#x27;</span>
  <span class="hljs-attr">client</span>:     <span class="hljs-title class_">Client</span>,
  <span class="hljs-attr">name</span>:       <span class="hljs-string">&#x27;NAME&#x27;</span>,
  <span class="hljs-attr">initMsg</span>:    <span class="hljs-keyword">async</span> () =&gt; ({})
})
</code></pre>
<h4 id="naming-and-labels" tabindex="-1">Naming and labels</h4>
<p>The chain requires labels to be unique.
Labels generated by Fadroma are of the format <code>${deployment.name}/${contract.name}</code>.</p>
<h4 id="lazy-init" tabindex="-1">Lazy init</h4>
<p>The <code>initMsg</code> property of <code>Contract</code> can be a function returning the actual message.
This function is only called during instantiation, and can be used to generate init
messages on the fly, such as when passing the address of one contract to another.</p>
<h4 id="deploying-contract-instances" tabindex="-1">Deploying contract instances</h4>
<p>To instantiate a <code>Contract</code>, its <code>agent</code> property must be set to a valid <code>Agent</code>.
When obtaining instances from a <code>Deployment</code>, their <code>agent</code> property is provided
from <code>deployment.agent</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Agent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fadroma/agent&#x27;</span>
<span class="hljs-title function_">assert</span>(deployment.<span class="hljs-property">a</span>.<span class="hljs-property">agent</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Agent</span>)
assert.<span class="hljs-title function_">equal</span>(deployment.<span class="hljs-property">a</span>.<span class="hljs-property">agent</span>, deployment.<span class="hljs-property">agent</span>)
</code></pre>
<p>You can instantiate a <code>Contract</code> by awaiting the <code>deployed</code> property or the return value of the
<code>deploy()</code> method. Since distributed ledgers are append-only, deployment is an idempotent operation,
so the deploy will run only once and subsequent calls will return the same <code>Contract</code> with the
same <code>address</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">await</span> deployment.<span class="hljs-property">a</span>.<span class="hljs-title function_">deploy</span>()
<span class="hljs-keyword">await</span> deployment.<span class="hljs-property">a</span>.<span class="hljs-property">deployed</span>
</code></pre>
<p>If <code>contract.codeId</code> is not set but either source code or a WASM binary is present,
this will try to upload and build the code first.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">await</span> deployment.<span class="hljs-property">a</span>.<span class="hljs-property">uploaded</span>
<span class="hljs-keyword">await</span> deployment.<span class="hljs-property">a</span>.<span class="hljs-title function_">upload</span>()

<span class="hljs-keyword">await</span> deployment.<span class="hljs-property">a</span>.<span class="hljs-property">built</span>
<span class="hljs-keyword">await</span> deployment.<span class="hljs-property">a</span>.<span class="hljs-title function_">build</span>()
</code></pre>
<h3 id="contract-templates" tabindex="-1">Contract templates</h3>
<p>The <code>Template</code> class represents a smart contract's source, compilation,
binary, and upload. It can have a <code>codeHash</code> and <code>codeId</code> but not an
<code>address</code>.</p>
<p><strong>Instantiating a template</strong> refers to calling the <code>template.instance</code>
method (or its plural, <code>template.instances</code>), which returns <code>Contract</code>,
which represents a particular smart contract instance, which can have
an <code>address</code>.</p>
<h4 id="deploying-multiple-contracts-from-a-template" tabindex="-1">Deploying multiple contracts from a template</h4>
<p>The <code>deployment.template</code> method adds a <code>Template</code> to the <code>Deployment</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// TODO</span>
</code></pre>
<p>You can pass either an array or an object to <code>template.instances</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// TODO</span>
</code></pre>
<h4 id="building-from-source-code" tabindex="-1">Building from source code</h4>
<p>To build, the <code>compiler</code> property must be set to a valid <code>Compiler</code>.
When obtaining instances from a <code>Deployment</code>, the <code>compiler</code> property
is provided automatically from <code>deployment.compiler</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// TODO</span>
</code></pre>
<p>You can build a <code>Template</code> (or its subclass, <code>Contract</code>) by awaiting the
<code>built</code> property or the return value of the <code>build()</code> method.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// TODO</span>
</code></pre>
<h4 id="uploading-binaries" tabindex="-1">Uploading binaries</h4>
<p>To upload, the <code>uploader</code> property must be set to a valid <code>Uploader</code>.
When obtaining instances from a <code>Deployment</code>, the <code>uploader</code> property
is provided automatically from <code>deployment.uploader</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// TODO</span>
</code></pre>
<p>You can upload a <code>Template</code> (or its subclass, <code>Contract</code>) by awaiting the
<code>uploaded</code> property or the return value of the <code>upload()</code> method.</p>
<p>If a WASM binary is not present (<code>template.artifact</code> is empty),
but a source and a compiler are present, this will also try to build the contract.</p>
<pre><code class="hljs language-typescript"><span class="hljs-comment">// TODO</span>
</code></pre>
<h2 id="services" tabindex="-1">Services</h2>
<h3 id="compiler" tabindex="-1">Compiler</h3>
<h3 id="uploader" tabindex="-1">Uploader</h3>
</content>
<nav class="ensuite-md-toc"><p><div class="table-of-contents"><ul><li><a href="#connecting-to-a-chain">Connecting to a chain</a><ul><li><a href="#block-height">Block height</a></li><li><a href="#native-tokens">Native tokens</a></li><li><a href="#querying-contracts">Querying contracts</a></li></ul></li><li><a href="#authenticating-an-agent">Authenticating an agent</a><ul><li><a href="#agent-identity">Agent identity</a></li><li><a href="#agents-and-block-height">Agents and block height</a></li><li><a href="#native-token-transactions">Native token transactions</a></li><li><a href="#uploading-and-instantiating-contracts">Uploading and instantiating contracts</a></li><li><a href="#executing-transactions-and-performing-queries">Executing transactions and performing queries</a></li><li><a href="#batching-transactions">Batching transactions</a></li></ul></li><li><a href="#gas-fees">Gas fees</a></li><li><a href="#contracts">Contracts</a><ul><li><a href="#contract-clients">Contract clients</a><ul><li><a href="#client-agent">Client agent</a></li><li><a href="#client-metadata">Client metadata</a></li></ul></li><li><a href="#contract-deployments">Contract deployments</a><ul><li><a href="#preparing">Preparing</a></li><li><a href="#deploying-everything">Deploying everything</a></li><li><a href="#expecting-contracts-to-be-deployed">Expecting contracts to be deployed</a></li><li><a href="#deploying-individual-contracts-with-dependencies">Deploying individual contracts with dependencies</a></li><li><a href="#deploying-with-custom-logic">Deploying with custom logic</a></li></ul></li><li><a href="#contract-instances">Contract instances</a><ul><li><a href="#naming-and-labels">Naming and labels</a></li><li><a href="#lazy-init">Lazy init</a></li><li><a href="#deploying-contract-instances">Deploying contract instances</a></li></ul></li><li><a href="#contract-templates">Contract templates</a><ul><li><a href="#deploying-multiple-contracts-from-a-template">Deploying multiple contracts from a template</a></li><li><a href="#building-from-source-code">Building from source code</a></li><li><a href="#uploading-binaries">Uploading binaries</a></li></ul></li></ul></li><li><a href="#services">Services</a><ul><li><a href="#compiler">Compiler</a></li><li><a href="#uploader">Uploader</a></li></ul></li></ul></div></p></nav>
</div>
</body>
</html>