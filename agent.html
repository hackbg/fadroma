<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Security-Policy" content="default-src 'self' http: https: ws: wss: 'unsafe-inline';">
</head>
<body>
<style name="assets/fonts.css" type="text/css">/* inter-regular - latin */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 400;
  src: url('assets/fonts/inter-v8-latin-regular.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('assets/fonts/inter-v8-latin-regular.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('assets/fonts/inter-v8-latin-regular.woff2') format('woff2'), /* Super Modern Browsers */
       url('assets/fonts/inter-v8-latin-regular.woff') format('woff'), /* Modern Browsers */
       url('assets/fonts/inter-v8-latin-regular.ttf') format('truetype'), /* Safari, Android, iOS */
       url('assets/fonts/inter-v8-latin-regular.svg#Inter') format('svg'); /* Legacy iOS */
}

/* inter-600 - latin */
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 600;
  src: url('assets/fonts/inter-v8-latin-600.eot'); /* IE9 Compat Modes */
  src: local(''),
       url('assets/fonts/inter-v8-latin-600.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('assets/fonts/inter-v8-latin-600.woff2') format('woff2'), /* Super Modern Browsers */
       url('assets/fonts/inter-v8-latin-600.woff') format('woff'), /* Modern Browsers */
       url('assets/fonts/inter-v8-latin-600.ttf') format('truetype'), /* Safari, Android, iOS */
       url('assets/fonts/inter-v8-latin-600.svg#Inter') format('svg'); /* Legacy iOS */
}


</style>
<style name="assets/style.css" type="text/css">* { box-sizing: border-box; margin: 0; padding: 0; line-height: 1.5; }

body { color: #123; font-size: 16px; font-family: "Inter", sans-serif; }
body { background-color: #f0f0f0; background-image: url('assets/bg.svg'); background-repeat: repeat; }

body > header {
  text-align: center;
  max-width: 80rem;
  margin: 0 auto;
  padding: 2rem 2rem 1rem;
}
body > header { display: flex; flex-flow: row nowrap; justify-content: space-around; align-items: center; }
body > header .logo, .logo img { display: block; margin: 0; flex-shrink: 1; }
body > header .logo img { max-width: 16rem; max-height: 16rem; }
body > header .badges { margin-bottom: 1rem; }
body > header a.badge { display: inline-block; padding: 0.25rem 0.5rem; }

section { padding: 1em; }

footer { padding: 1em; }

a { text-decoration: none; }
a:hover { text-decoration: underline; }
a, a:focus, a:visited, a:active, a:hover { color: rgb(101, 179, 76) }

h1, h2, h3, h4 { font-weight: 600 }
h1 { font-size: 3em;     line-height: 3rem;   margin-bottom: 2rem;                     }
h2 { font-size: 1.75em;  line-height: 2rem;   margin-bottom: 1rem;   margin-top: 0;    }
h3 { font-size: 1.5rem;  line-height: 2rem;   margin-bottom: 1rem;                     }
h4 { font-size: 1.25em;  line-height: 1.5rem; margin-bottom: 0.5rem; margin-top: 2rem; }
h5 { font-size: 1.125em; line-height: 1.5rem; margin-bottom: 0.5rem; margin-top: 2rem; }

button, .button {
  display: inline-block;
  background: rgb(101, 179, 76);
  color: white;
  padding: 0 1em;
  margin: 1em 0;
  text-shadow: -1px -1px 0 black;
  box-shadow: 1px 1px 0 black;
}
a.button:focus, a.button:visited, a.button:active, a.button:hover {
  color: white;
}

table { width: 50%; width: 50vw; margin: 0 auto 5em; }
th, td { text-align: left; vertical-align: top; }
th { padding-right: 5em }

.grid {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  flex-flow: row wrap;
  justify-content: center;
  max-width: 80rem;
  margin: 0 auto 3rem;
}

@media (max-width: 80rem) {
  .grid {
    display: flex;
    flex-flow: column nowrap;
  }
  .grid .feature {
    display: flex;
    flex-flow: row nowrap;
  }
  .grid .feature .links {
    flex-shrink: 0;
    width: 33%;
    margin: 0 0 0 2rem;
  }
  .table-of-contents {
    width: 1rem;
  }
}

@media (max-width: 48rem) {
  .grid .feature .links {
    width: 50%;
  }
}

.big-left { grid-column-start: 1; grid-column-end: 3; }
.big-center { grid-column-start: 2; grid-column-end: 4; }
.big-right { grid-column-start: 3; grid-column-end: 5; }
.big-all { grid-column-start: 1; grid-column-end: 5; }

.feature {
  padding: 1rem;
  margin: 1rem 0.5rem 0;
  border: 1px solid rgba(0,0,0,0.1);
  border-top-color: rgba(255,255,255,0.5);
  border-left-color: rgba(255,255,255,0.5);
  border-radius: 3px;
  box-shadow: 3px 3px 6px rgba(0,0,0,0.1);
  display: flex;
  flex-flow: column nowrap;
  background: #fff;
}

.feature .docs {
  font-weight: bold;
}

#features .feature {
  min-height: 10rem;
}

.left {
  text-align: left;
}
.center {
  text-align: center;
}

.feature .description {
  line-height: 1.5;
  font-size: 0.875rem;
}

code.inline,
code.block {
  background:  #0c5749;
  color:       white;
  font-family: monospace;
  font-weight: bold;
}

code.inline {
  display: inline-block;
  padding: 0.5rem 1rem;
  margin: 0 0.5rem;
}

code.block {
  display: block;
  padding:     1rem;
  margin:        1rem auto;
  border-radius: 0.5rem;
  max-width:     40rem;
  line-height:   1rem;
}

.feature-logo {
  margin-bottom: 0.5rem;
  height:        5rem;
  width:         12rem;
  align-self:    center;
}

.tag {
  font-size: 0.8rem;
  background: #f5faf3;
  border: 1px solid #437733;
  color: #437733;
  display: inline-block;
  padding: 0.25rem 0.5rem;
  margin: 0.5rem 0 0;
  align-self: flex-start;
  border-radius: 3px;
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.spacer {
  flex-grow:  1;
  min-height: 0.5rem;
}

pre, code {
  font-family: monospace;
}

p {
  line-height: 1.5rem;
  margin-top: 0;
  margin-bottom: 0.5rem;
}

svg.icon {
  width: 2rem;
  height: 2rem;
}
a > svg.icon {
  fill: rgb(101, 179, 76);
  width: 1.5rem;
  height: 1.5rem;
  line-height: 1rem;
  vertical-align: baseline;
  margin-right: 0.5rem;
  flex-shrink: 0;
}
.feature a.docs {
  display: flex;
  flex-flow: row nowrap;
  align-items: flex-start;
  font-weight: normal;
  text-decoration: none;
  padding: 0.5rem 0;
  cursor: default;
  color: #888;
}
.feature a.docs[href] {
  text-decoration: underline;
  color: rgb(67, 119, 51);
  cursor: pointer;
}

@keyframes hourglass {
  50%  { transform: rotateZ(0);      }
	100% { transform: rotateZ(180deg); }
}

svg.icon-todo {
  animation-name: hourglass;
  animation-duration: 3s;
  animation-delay: 1s;
  animation-iteration-count: infinite;
}

.links {
  display: flex;
  flex-flow: column nowrap;
}
.links > a {
  margin-right: 1rem;
  transition:
    padding-left 0.33s,
    margin-right 0.33s;
}
.links > a[href]:hover {
  padding-left: 0.5rem;
  margin-right: 0.5rem;
}
.feature pre {
  background: #eee;
  padding: 0.5rem;
  border-radius: 0.1rem;
  font-size: 0.875rem;
  font-weight: normal;
  margin-top: 1rem;
  color: #555;
}

/*.feature .links .icon { fill: #F46623 }*/

.feature.invert { background: rgb(67, 119, 51); color: white; }
.feature.invert * { color: white; fill: white; }
.feature.invert a.docs { color: white; }
.feature.invert a.docs[href] { text-decoration: underline; }

.feature.foss { background: #2e0056; color: white; }
.feature.foss * { color: white; fill:  white; }
.feature.foss a.docs { color: white; }

.icon-todo { fill: #aaa !important; }

#quick-start {
  text-align: center;
  flex-grow: 1;
}

.ensuite-md-rendered {
  background: white;
  display: block;
  max-width: 54rem;
  margin: 0 auto 0 38%;
  padding: 3rem;
  box-shadow: 3px 3px 6px rgba(0,0,0,0.1)
}
.ensuite-md-rendered .table-of-contents {
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
  width: 38%;
  background: rgb(67, 119, 51);
  color: white;
  padding: 2rem 0 2rem 1rem;
  border-right: 1px solid #888;
  display: flex;
  justify-content: flex-end;
}
.ensuite-md-rendered h2 { margin-top: 2.5rem; margin-bottom: 0.5rem; }
.ensuite-md-rendered h3 { margin-top: 1.5rem; margin-bottom: 0.5rem; }

ul { margin-left: 1em; }

p > code { font-weight: bold; color: #345 }
pre > code {
  display: block;
  border: 1px solid #888;
  padding: 0.5rem 1rem;
  margin-bottom: 1rem;
  background: rgba(255,255,255,0.5);
  box-shadow: 2px 2px 2px #888;
  overflow-x: auto;
  margin: 1rem -1rem;
}
pre > code.language-sh {
  background: #123;
  border-radius: 0;
  color: #fe0;
}
pre > code.language-typescript {
  background: #ffe;
  border-radius: 0.15rem;
}

.table-of-contents { overflow: auto }
.table-of-contents a { display: block; color: white; text-decoration: underline 1px dotted black; padding: 0.25rem 1.5rem 0.25rem }
.table-of-contents a:hover { color: black; text-decoration: underline 1px solid rgba(0,0,0,0.75); background: #fff }
.table-of-contents li { margin: 0 0 }
.table-of-contents ul { font-weight: bold; margin-left: 0; list-style: none }
.table-of-contents ul ul { font-weight: normal; margin-left: 1em }
</style>
<content class="ensuite-md-rendered">
<p><div class="table-of-contents"><ul><li><a href="#chain">Chain</a><ul><li><a href="#chain-modes">Chain modes</a></li><li><a href="#dev-mode">Dev mode</a></li></ul></li><li><a href="#agent">Agent</a><ul><li><a href="#block-height">Block height</a></li><li><a href="#native-token-transactions">Native token transactions</a></li><li><a href="#default-gas-fees">Default gas fees</a></li><li><a href="#uploading-code">Uploading code</a></li><li><a href="#instantiating-contracts">Instantiating contracts</a></li><li><a href="#querying-contract-state">Querying contract state</a></li><li><a href="#executing-transactions">Executing transactions</a></li><li><a href="#batching-transactions">Batching transactions</a></li></ul></li><li><a href="#client">Client</a><ul><li><a href="#metadata">Metadata</a></li><li><a href="#client-agent">Client agent</a></li><li><a href="#defining-query-and-transaction-methods">Defining query and transaction methods</a></li><li><a href="#per-transaction-fees">Per-transaction fees</a></li></ul></li></ul></div></p>
<h1 id="fadroma-guide%3A-agent-api" tabindex="-1">Fadroma Guide: Agent API</h1>
<p>The <strong>Agent API</strong> is a simple imperative transaction-level API for
interacting with Cosmos-like networks.</p>
<p>Its core primitives are the <strong><code>Chain</code></strong> and <strong><code>Agent</code></strong> abstract classes.
An <code>Agent</code> corresponds to your identity (wallet) on a given chain,
and lets you operate in terms of transactions (sending tokens, calling contracts, etc.)</p>
<ul>
<li><a href="./Scrt.spec.ts.md"><strong><code>@fadroma/scrt</code></strong></a> provides
<strong><code>ScrtChain</code></strong> and <strong><code>ScrtAgent</code></strong>, the concrete implementations
of Fadroma Chain API for Secret Network.</li>
</ul>
<h2 id="chain" tabindex="-1">Chain</h2>
<p>The <code>Chain</code> object identifies what chain to connect to -
such as the Secret Network mainnet or testnet.</p>
<p>Since the workflow is request-based, no persistent connection is maintained.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Chain</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fadroma/agent&#x27;</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">chain</span>: <span class="hljs-title class_">Chain</span>
</code></pre>
<h3 id="chain-modes" tabindex="-1">Chain modes</h3>
<p>Chains can be in several <code>mode</code>s, enumerated by <code>ChainMode</code> a.k.a. <code>Chain.Mode</code>.
To connect to a chain in a specific mode, you can use the corresponding static
method on the <code>Chain</code></p>
<p><strong>Mainnet</strong> is the production chain where value is stored.</p>
<pre><code class="hljs language-typescript">chain = <span class="hljs-title class_">Chain</span>.<span class="hljs-title function_">mainnet</span>({ <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;example.com&#x27;</span> })

<span class="hljs-title function_">assert</span>(!chain.<span class="hljs-property">devMode</span>)
<span class="hljs-title function_">assert</span>(chain.<span class="hljs-property">isMainnet</span>)
</code></pre>
<p><strong>Testnet</strong> is a persistent remote chain used for testing.</p>
<pre><code class="hljs language-typescript">chain = <span class="hljs-title class_">Chain</span>.<span class="hljs-title function_">testnet</span>({ <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;example.com&#x27;</span> })

<span class="hljs-title function_">assert</span>(!chain.<span class="hljs-property">devMode</span>)
<span class="hljs-title function_">assert</span>(chain.<span class="hljs-property">isTestnet</span>)
<span class="hljs-title function_">assert</span>(!chain.<span class="hljs-property">isMainnet</span>)
</code></pre>
<p><a href="../devnet/Devnet.spec.ts.md"><strong>Devnet</strong></a> uses a real chain node, booted up temporarily in
a local environment.</p>
<pre><code class="hljs language-typescript">chain = <span class="hljs-title class_">Chain</span>.<span class="hljs-title function_">devnet</span>({ <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;example.com&#x27;</span> })

<span class="hljs-title function_">assert</span>(chain.<span class="hljs-property">devMode</span>)
<span class="hljs-title function_">assert</span>(chain.<span class="hljs-property">isDevnet</span>)
<span class="hljs-title function_">assert</span>(!chain.<span class="hljs-property">isMainnet</span>)
</code></pre>
<p><a href="../mocknet/Mocknet.spec.ts.md"><strong>Mocknet</strong></a> is a fast, nodeless way of executing contract code
in the local JS WASM runtime.</p>
<pre><code class="hljs language-typescript">chain = <span class="hljs-title class_">Chain</span>.<span class="hljs-title function_">mocknet</span>({ <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;example.com&#x27;</span> })

<span class="hljs-title function_">assert</span>(chain.<span class="hljs-property">devMode</span>)
<span class="hljs-title function_">assert</span>(chain.<span class="hljs-property">isMocknet</span>)
<span class="hljs-title function_">assert</span>(!chain.<span class="hljs-property">isMainnet</span>)
</code></pre>
<h3 id="dev-mode" tabindex="-1">Dev mode</h3>
<p>The <code>chain.devMode</code> flag is true if you are able to restart
the chain and start over (i.e. when using a devnet or mocknet).</p>
<h2 id="agent" tabindex="-1">Agent</h2>
<p>To transact on a <a href="./Chains.ts.md">chain</a>, you need to authenticate
with your identity (account, wallet). To do that, you obtain an
<code>Agent</code> from the <code>Chain</code> using <code>chain.getAgent({...})</code>.</p>
<p>If you don't pass a mnemonic, a random mnemonic and address will be generated.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Agent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fadroma/agent&#x27;</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">agent</span>: <span class="hljs-title class_">Agent</span> = <span class="hljs-keyword">await</span> chain.<span class="hljs-title function_">getAgent</span>({ <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;testing1agent0&#x27;</span> })

assert.<span class="hljs-title function_">ok</span>(agent <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Agent</span>, <span class="hljs-string">&#x27;an Agent was returned&#x27;</span>)
assert.<span class="hljs-title function_">equal</span>(agent.<span class="hljs-property">chain</span>, chain,  <span class="hljs-string">&#x27;agent.chain assigned&#x27;</span>)
assert.<span class="hljs-title function_">equal</span>(agent.<span class="hljs-property">address</span>, <span class="hljs-string">&#x27;testing1agent0&#x27;</span>,  <span class="hljs-string">&#x27;agent.address assigned&#x27;</span>)
</code></pre>
<h3 id="block-height" tabindex="-1">Block height</h3>
<p>Having obtained an <code>Agent</code>, you are ready to begin performing operations.
The simplest thing to do is waiting until the block height increments.
The block height is the heartbeat of the blockchain.</p>
<ul>
<li>On Secret Network, this can be necessary for uploading multiple contracts.</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> height = <span class="hljs-keyword">await</span> agent.<span class="hljs-property">height</span> <span class="hljs-comment">// Get the current block height</span>

<span class="hljs-comment">//await agent.nextBlock             // Wait for the block height to increment</span>
<span class="hljs-comment">//assert.equal(await agent.height, height + 1)</span>
</code></pre>
<h3 id="native-token-transactions" tabindex="-1">Native token transactions</h3>
<p>You're not on the chain to wait around, though.
The simplest operation you can conduct is transact with native tokens:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">await</span> agent.<span class="hljs-property">balance</span>             <span class="hljs-comment">// In the default native token</span>
<span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">getBalance</span>()        <span class="hljs-comment">// In the default native token</span>
<span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">getBalance</span>(<span class="hljs-string">&#x27;token&#x27;</span>) <span class="hljs-comment">// In a non-default native token</span>

<span class="hljs-comment">// Sending the default native token:</span>
<span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;recipient-address&#x27;</span>, <span class="hljs-number">1000</span>)
<span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;recipient-address&#x27;</span>, <span class="hljs-string">&#x27;1000&#x27;</span>)

<span class="hljs-comment">// Sending a non-default native token:</span>
<span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;recipient-address&#x27;</span>, [{<span class="hljs-attr">denom</span>:<span class="hljs-string">&#x27;token&#x27;</span>, <span class="hljs-attr">amount</span>: <span class="hljs-string">&#x27;1000&#x27;</span>}])
</code></pre>
<h3 id="default-gas-fees" tabindex="-1">Default gas fees</h3>
<p>Transacting creates load on the network, which incurs costs on node operators.
Compensations for transactions are represented by the gas metric.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Fee</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fadroma/agent&#x27;</span>
</code></pre>
<h3 id="uploading-code" tabindex="-1">Uploading code</h3>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { nullWasm } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../fixtures/Fixtures.ts.md&#x27;</span>

<span class="hljs-comment">// Uploading from a Buffer</span>
<span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">upload</span>(nullWasm)

<span class="hljs-comment">// Uploading from a filename</span>
<span class="hljs-comment">//await agent.upload(&#x27;example.wasm&#x27;)</span>

<span class="hljs-comment">// Uploading an Uploadable object</span>
<span class="hljs-comment">//await agent.upload({ artifact: &#x27;./example.wasm&#x27;, codeHash: &#x27;expectedCodeHash&#x27; })</span>

<span class="hljs-comment">// Uploading multiple pieces of code:</span>
<span class="hljs-comment">/*await agent.uploadMany([
  &#x27;example.wasm&#x27;,
  readFileSync(&#x27;example.wasm&#x27;),
  { artifact: &#x27;./example.wasm&#x27;, codeHash: &#x27;expectedCodeHash&#x27; }
])*/</span>
</code></pre>
<p>The code ID is a unique identifier for compiled code uploaded to a chain.</p>
<p>The code hash also uniquely identifies for the code that underpins a contract.
However, unlike the code ID, which is opaque, the code hash corresponds to the
actual content of the code. Uploading the same code multiple times will give
you different code IDs, but the same code hash.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> {  assertCodeHash, codeHashOf } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fadroma/agent&#x27;</span>

assert.<span class="hljs-title function_">ok</span>(<span class="hljs-title function_">assertCodeHash</span>({ <span class="hljs-attr">codeHash</span>: <span class="hljs-string">&#x27;code-hash-stub&#x27;</span> }))
assert.<span class="hljs-title function_">throws</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">assertCodeHash</span>({}))

assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">codeHashOf</span>({ <span class="hljs-attr">codeHash</span>: <span class="hljs-string">&#x27;hash&#x27;</span> }), <span class="hljs-string">&#x27;hash&#x27;</span>)
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">codeHashOf</span>({ <span class="hljs-attr">code_hash</span>: <span class="hljs-string">&#x27;hash&#x27;</span> }), <span class="hljs-string">&#x27;hash&#x27;</span>)
assert.<span class="hljs-title function_">throws</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">codeHashOf</span>({ <span class="hljs-attr">code_hash</span>: <span class="hljs-string">&#x27;hash1&#x27;</span>, <span class="hljs-attr">codeHash</span>: <span class="hljs-string">&#x27;hash2&#x27;</span> }))
</code></pre>
<h3 id="instantiating-contracts" tabindex="-1">Instantiating contracts</h3>
<ul>
<li>Instantiating a single contract:</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">instantiate</span>({ <span class="hljs-attr">codeId</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;unique1&#x27;</span>, <span class="hljs-attr">initMsg</span>: { <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;val&#x27;</span> } })
</code></pre>
<ul>
<li>Instantiating multiple contracts in a single transaction:</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">instantiateMany</span>([
  { <span class="hljs-attr">codeId</span>: <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;unique2&#x27;</span>, <span class="hljs-attr">initMsg</span>: { <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;values&#x27;</span> } },
  { <span class="hljs-attr">codeId</span>: <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;unique3&#x27;</span>, <span class="hljs-attr">initMsg</span>: { <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;values&#x27;</span> } }
})
</code></pre>
<h3 id="querying-contract-state" tabindex="-1">Querying contract state</h3>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> response =
  <span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">query</span>({ <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;address&#x27;</span>, <span class="hljs-attr">codeHash</span>: <span class="hljs-string">&#x27;codeHash&#x27;</span> }, { <span class="hljs-attr">method</span>: { <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;val&#x27;</span> } })
</code></pre>
<h3 id="executing-transactions" tabindex="-1">Executing transactions</h3>
<p>Executing a single transaction:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> result =
  <span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">execute</span>({ <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;address&#x27;</span>, <span class="hljs-attr">codeHash</span>: <span class="hljs-string">&#x27;codeHash&#x27;</span> }, { <span class="hljs-attr">method</span>: { <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;val&#x27;</span> } })
</code></pre>
<p>Broadcasting multiple execute calls as a single transaction message
(transaction bundling):</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> agent.<span class="hljs-title function_">bundle</span>(<span class="hljs-keyword">async</span> bundle=&gt;{
  <span class="hljs-keyword">await</span> bundle.<span class="hljs-title function_">execute</span>({ <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;address&#x27;</span>, <span class="hljs-attr">codeHash</span>: <span class="hljs-string">&#x27;codeHash&#x27;</span> }, { <span class="hljs-attr">method</span>: { <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;val&#x27;</span> } })
  <span class="hljs-keyword">await</span> bundle.<span class="hljs-title function_">execute</span>({ <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;address&#x27;</span>, <span class="hljs-attr">codeHash</span>: <span class="hljs-string">&#x27;codeHash&#x27;</span> }, { <span class="hljs-attr">method</span>: { <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;val&#x27;</span> } })
}).<span class="hljs-title function_">run</span>()
</code></pre>
<h3 id="batching-transactions" tabindex="-1">Batching transactions</h3>
<p>To submit multiple messages as a single transaction, you can
use the <code>Bundle</code> class through <code>Agent#bundle</code>.</p>
<ul>
<li>A <code>Bundle</code> is a special kind of <code>Agent</code> that
does not broadcast messages immediately.</li>
<li>Instead, messages are collected inside the bundle until
the caller explicitly submits them.</li>
<li>Bundles can also be saved for manual signing of multisig
transactions</li>
</ul>
<p>A <code>Bundle</code> is designed to serve as a stand-in for its corresponding
<code>Agent</code>, and therefore implements the same API methods.</p>
<ul>
<li>However, some operations don't make sense in the middle of a Bundle.</li>
<li>Most importantly, querying any state from the chain
must be done either before or after the bundle.</li>
<li>Trying to query state from a <code>Bundle</code> agent will fail.</li>
</ul>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Chain</span>, <span class="hljs-title class_">Agent</span>, <span class="hljs-title class_">Bundle</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fadroma/agent&#x27;</span>
chain = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chain</span>({ <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;example.com&#x27;</span>, <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;mainnet&#x27;</span> })
agent = <span class="hljs-keyword">await</span> chain.<span class="hljs-title function_">getAgent</span>()
<span class="hljs-keyword">let</span> <span class="hljs-attr">bundle</span>: <span class="hljs-title class_">Bundle</span>
</code></pre>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Client</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fadroma/agent&#x27;</span>
bundle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>(agent)

<span class="hljs-title function_">assert</span>(bundle.<span class="hljs-title function_">getClient</span>(<span class="hljs-title class_">Client</span>, <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Client</span>, <span class="hljs-string">&#x27;Bundle#getClient&#x27;</span>)
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-keyword">await</span> bundle.<span class="hljs-title function_">execute</span>({}), bundle)
assert.<span class="hljs-title function_">equal</span>(bundle.<span class="hljs-property">id</span>, <span class="hljs-number">1</span>)
<span class="hljs-comment">//assert(await bundle.instantiateMany({}, []))</span>
<span class="hljs-comment">//assert(await bundle.instantiateMany({}, [[&#x27;label&#x27;, &#x27;init&#x27;]]))</span>
<span class="hljs-comment">//assert(await bundle.instantiate({}, &#x27;label&#x27;, &#x27;init&#x27;))</span>
assert.<span class="hljs-title function_">equal</span>(<span class="hljs-keyword">await</span> bundle.<span class="hljs-title function_">checkHash</span>(), <span class="hljs-string">&#x27;code-hash-stub&#x27;</span>)

assert.<span class="hljs-title function_">rejects</span>(<span class="hljs-function">()=&gt;</span>bundle.<span class="hljs-title function_">query</span>())
assert.<span class="hljs-title function_">rejects</span>(<span class="hljs-function">()=&gt;</span>bundle.<span class="hljs-title function_">upload</span>())
assert.<span class="hljs-title function_">rejects</span>(<span class="hljs-function">()=&gt;</span>bundle.<span class="hljs-title function_">uploadMany</span>())
assert.<span class="hljs-title function_">rejects</span>(<span class="hljs-function">()=&gt;</span>bundle.<span class="hljs-title function_">sendMany</span>())
assert.<span class="hljs-title function_">rejects</span>(<span class="hljs-function">()=&gt;</span>bundle.<span class="hljs-title function_">send</span>())
assert.<span class="hljs-title function_">rejects</span>(<span class="hljs-function">()=&gt;</span>bundle.<span class="hljs-title function_">getBalance</span>())
assert.<span class="hljs-title function_">throws</span>(<span class="hljs-function">()=&gt;</span>bundle.<span class="hljs-property">height</span>)
assert.<span class="hljs-title function_">throws</span>(<span class="hljs-function">()=&gt;</span>bundle.<span class="hljs-property">nextBlock</span>)
assert.<span class="hljs-title function_">throws</span>(<span class="hljs-function">()=&gt;</span>bundle.<span class="hljs-property">balance</span>)
</code></pre>
<p>To create and submit a bundle in a single expression,
you can use <code>bundle.wrap(async (bundle) =&gt; { ... })</code>:</p>
<h2 id="client" tabindex="-1">Client</h2>
<p>Represents an interface to an existing contract.</p>
<ul>
<li>The default <code>Client</code> class allows passing messages to the contract instance.</li>
<li><strong>Implement a custom subclass of <code>Client</code> to define specific messages as methods</strong>.
This is the main thing to do when defining your Fadroma Client-based API.</li>
</ul>
<p>User interacts with contract by obtaining an instance of the
appropriate <code>Client</code> subclass from the authorized <code>Agent</code>.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Client</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fadroma/agent&#x27;</span>
<span class="hljs-keyword">let</span> address = <span class="hljs-string">&#x27;some-addr&#x27;</span>
<span class="hljs-keyword">let</span> codeHash = <span class="hljs-string">&#x27;some-hash&#x27;</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">client</span>: <span class="hljs-title class_">Client</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>({ agent, address, codeHash })

assert.<span class="hljs-title function_">equal</span>(client.<span class="hljs-property">agent</span>,    agent)
assert.<span class="hljs-title function_">equal</span>(client.<span class="hljs-property">address</span>,  address)
assert.<span class="hljs-title function_">equal</span>(client.<span class="hljs-property">codeHash</span>, codeHash)

client.<span class="hljs-property">fees</span> = { <span class="hljs-string">&#x27;method&#x27;</span>: <span class="hljs-number">100</span> }

assert.<span class="hljs-title function_">equal</span>(client.<span class="hljs-title function_">getFee</span>(<span class="hljs-string">&#x27;method&#x27;</span>), <span class="hljs-number">100</span>)

assert.<span class="hljs-title function_">equal</span>(client.<span class="hljs-title function_">getFee</span>({<span class="hljs-string">&#x27;method&#x27;</span>:{<span class="hljs-string">&#x27;parameter&#x27;</span>:<span class="hljs-string">&#x27;value&#x27;</span>}}), <span class="hljs-number">100</span>)

<span class="hljs-keyword">let</span> agent2 = <span class="hljs-title class_">Symbol</span>()
assert.<span class="hljs-title function_">equal</span>(
  client.<span class="hljs-title function_">withAgent</span>(agent2).<span class="hljs-property">agent</span>,
  agent2
)

client.<span class="hljs-property">agent</span> = { <span class="hljs-attr">execute</span>: <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-string">&#x27;ok&#x27;</span> }
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">execute</span>({<span class="hljs-string">&#x27;method&#x27;</span>:{<span class="hljs-string">&#x27;parameter&#x27;</span>:<span class="hljs-string">&#x27;value&#x27;</span>}}),
  <span class="hljs-string">&#x27;ok&#x27;</span>
)
</code></pre>
<p>Once you know what methods your contract will support,
you'll want to extend <code>Client</code> and implement them there:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Client</span> {
  address = <span class="hljs-string">&#x27;unspecified&#x27;</span>
  myMethod = <span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">execute</span>({ <span class="hljs-attr">my_method</span>: { param } })
  myQuery = <span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">query</span>({ <span class="hljs-attr">my_query</span>: { param } }) }
}
</code></pre>
<p>By publishing a library of <code>Client</code> subclasses corresponding to your contracts,
you can provide a robust API to users of your project, so that they can in turn
integrate it into their systems.</p>
<h3 id="metadata" tabindex="-1">Metadata</h3>
<p>The original <code>Contract</code> object from which the contract
was deployed can be found on the optional <code>meta</code> property of the <code>Client</code>.</p>
<pre><code class="hljs language-typescript">assert.<span class="hljs-title function_">ok</span>(aClient.<span class="hljs-property">meta</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Contract</span>)
assert.<span class="hljs-title function_">equal</span>(aClient.<span class="hljs-property">meta</span>.<span class="hljs-property">deployedBy</span>, agent.<span class="hljs-property">address</span>)
</code></pre>
<p>Fetching metadata:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { fetchCodeHash, fetchCodeId, fetchLabel } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fadroma/agent&#x27;</span>

instance.<span class="hljs-property">address</span> = <span class="hljs-string">&#x27;someaddress&#x27;</span> <span class="hljs-comment">// FIXME</span>
assert.<span class="hljs-title function_">ok</span>(instance.<span class="hljs-property">codeHash</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchCodeHash</span>(instance, agent))
<span class="hljs-comment">//assert.ok(instance.codeId   = await fetchCodeId(instance, agent))</span>
assert.<span class="hljs-title function_">ok</span>(instance.<span class="hljs-property">label</span>    = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchLabel</span>(instance, agent))

assert.<span class="hljs-title function_">equal</span>(instance.<span class="hljs-property">codeHash</span>, <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchCodeHash</span>(instance, agent, instance.<span class="hljs-property">codeHash</span>))
<span class="hljs-comment">//assert.equal(instance.codeId,   await fetchCodeId(instance, agent, instance.codeId))</span>
assert.<span class="hljs-title function_">equal</span>(instance.<span class="hljs-property">label</span>,    <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchLabel</span>(instance, agent, instance.<span class="hljs-property">label</span>))

assert.<span class="hljs-title function_">rejects</span>(<span class="hljs-title function_">fetchCodeHash</span>(instance, agent, <span class="hljs-string">&#x27;unexpected&#x27;</span>))
assert.<span class="hljs-title function_">rejects</span>(<span class="hljs-title function_">fetchCodeId</span>(instance, agent, <span class="hljs-string">&#x27;unexpected&#x27;</span>))
assert.<span class="hljs-title function_">rejects</span>(<span class="hljs-title function_">fetchLabel</span>(instance, agent, <span class="hljs-string">&#x27;unexpected&#x27;</span>))
</code></pre>
<h3 id="client-agent" tabindex="-1">Client agent</h3>
<p>By default, the <code>Client</code>'s <code>agent</code> property is equal to the <code>agent</code>
which deployed the contract. This property determines the address from
which subsequent transactions with that <code>Client</code> will be sent.</p>
<p>In case you want to deploy the contract as one identity, then interact
with it from another one as part of the same procedure, you can set <code>agent</code>
to another instance of <code>Agent</code>:</p>
<pre><code class="hljs language-typescript">assert.<span class="hljs-title function_">equal</span>(aClient.<span class="hljs-property">agent</span>, agent)
aClient.<span class="hljs-property">agent</span> = <span class="hljs-keyword">await</span> chain.<span class="hljs-title function_">getAgent</span>()
</code></pre>
<p>Similarly to <code>withFee</code>, the <code>as</code> method returns a new instance of your
client class, bound to a different <code>agent</code>, thus allowing you to execute
transactions as a different identity.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> agent1 = <span class="hljs-keyword">await</span> chain.<span class="hljs-title function_">getAgent</span>(<span class="hljs-comment">/*...*/</span>)
<span class="hljs-keyword">const</span> agent2 = <span class="hljs-keyword">await</span> chain.<span class="hljs-title function_">getAgent</span>(<span class="hljs-comment">/*...*/</span>)

<span class="hljs-keyword">const</span> client = agent1.<span class="hljs-title function_">getClient</span>(<span class="hljs-title class_">MyContract</span>, <span class="hljs-string">&quot;...&quot;</span>)

<span class="hljs-comment">// signed by agent1:</span>
client.<span class="hljs-title function_">tx1</span>()

<span class="hljs-comment">// signed by agent2</span>
client.<span class="hljs-title function_">asAgent</span>(agent2).<span class="hljs-title function_">tx1</span>()
</code></pre>
<h3 id="defining-query-and-transaction-methods" tabindex="-1">Defining query and transaction methods</h3>
<p>The main things that you need to know for implementing a client class
are the <code>query</code> and <code>execute</code> methods:</p>
<ul>
<li>You pass them the message as a JS object.</li>
<li>They serialize it to JSON and pass it to the contract.</li>
<li>Then, they return a <code>Promise</code> of the value returned by the contract.</li>
<li>If the returned value is an error, the promise will reject (i.e. if you're
<code>await</code>ing the promise chain, an <code>Error</code> will be thrown).</li>
</ul>
<h3 id="per-transaction-fees" tabindex="-1">Per-transaction fees</h3>
<p>You can specify default gas limits for each method by defining the <code>fees: Record&lt;string, IFee&gt;</code>
property of your client class:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Client</span>, <span class="hljs-title class_">Fee</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fadroma/agent&#x27;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyContract</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Client</span> {

  tx1 = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">execute</span>(<span class="hljs-string">&quot;tx1&quot;</span>)

  tx2 = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">execute</span>({<span class="hljs-attr">tx2</span>: n})

  tx3 = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">execute</span>({<span class="hljs-attr">tx3</span>: {}})

  tx4 = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">execute</span>({<span class="hljs-attr">tx4</span>: {<span class="hljs-attr">my_value</span>: n}})

  fees = {
    <span class="hljs-attr">tx1</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fee</span>(<span class="hljs-string">&#x27;10000&#x27;</span>, <span class="hljs-string">&#x27;uscrt&#x27;</span>),
    <span class="hljs-attr">tx2</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fee</span>(<span class="hljs-string">&#x27;20000&#x27;</span>, <span class="hljs-string">&#x27;uscrt&#x27;</span>),
    <span class="hljs-attr">tx3</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fee</span>(<span class="hljs-string">&#x27;30000&#x27;</span>, <span class="hljs-string">&#x27;uscrt&#x27;</span>),
    <span class="hljs-attr">tx4</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fee</span>(<span class="hljs-string">&#x27;40000&#x27;</span>, <span class="hljs-string">&#x27;uscrt&#x27;</span>),
  }

}
</code></pre>
<p>You can also specify one fee for all transactions, using <code>client.withFee({ gas, amount: [...] })</code>.
This method works by returning a copy of <code>client</code> with fees overridden by the provided value.</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">const</span> fee = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fee</span>(<span class="hljs-string">&#x27;100000&#x27;</span>, <span class="hljs-string">&#x27;uscrt&#x27;</span>)

<span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">withFee</span>(fee).<span class="hljs-title function_">tx1</span>()
</code></pre>

</content>
</body>
</html>